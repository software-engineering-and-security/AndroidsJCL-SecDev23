{"ssl/ClientHandshaker.java": {"chunk_0": {"plus_lines": ["         // session ID of the ClientHello message", "        SessionId sessionId = new SessionId(new byte[0]);", " "], "minus_lines": ["         // session ID of the ClientHello message", "        SessionId sessionId = SSLSessionImpl.nullSession.getSessionId();", " "]}}, "ssl/SSLEngineImpl.java": {"chunk_1": {"plus_lines": ["         sslContext = ctx;", "        sess = new SSLSessionImpl();", "         handshakeSession = null;"], "minus_lines": ["         sslContext = ctx;", "        sess = SSLSessionImpl.nullSession;", "         handshakeSession = null;"]}}, "ssl/SSLSessionImpl.java": {"chunk_2": {"plus_lines": [], "minus_lines": [" ", "    /*", "     * we only really need a single null session", "     */", "    static final SSLSessionImpl         nullSession = new SSLSessionImpl();", "", "     // compression methods"]}, "chunk_3": {"plus_lines": ["      */", "    SSLSessionImpl() {", "         this(ProtocolVersion.NONE, CipherSuite.C_NULL, null,"], "minus_lines": ["      */", "    private SSLSessionImpl() {", "         this(ProtocolVersion.NONE, CipherSuite.C_NULL, null,"]}, "chunk_4": {"plus_lines": [], "minus_lines": ["     synchronized public void invalidate() {", "        //", "        // Can't invalidate the NULL session -- this would be", "        // attempted when we get a handshaking error on a brand", "        // new connection, with no \"real\" session yet.", "        //", "        if (this == nullSession) {", "            return;", "        }", "         invalidated = true;"]}}, "ssl/SSLSocketImpl.java": {"chunk_5": {"plus_lines": ["         sslContext = context;", "        sess = new SSLSessionImpl();", "         handshakeSession = null;"], "minus_lines": ["         sslContext = context;", "        sess = SSLSessionImpl.nullSession;", "         handshakeSession = null;"]}}}