{
    "cert/CertPathHelperImpl.java": {
        "chunk_0": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2002, 2009, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_1": {
            "plus_lines": [
                "     }",
                "",
                "    protected boolean implIsJdkCA(TrustAnchor anchor) {",
                "        return anchor.isJdkCA();",
                "    }",
                " }"
            ],
            "minus_lines": []
        }
    },
    "cert/TrustAnchor.java": {
        "chunk_2": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_3": {
            "plus_lines": [
                " ",
                "import sun.security.util.AnchorCertificates;",
                " import sun.security.x509.NameConstraintsExtension;"
            ],
            "minus_lines": []
        },
        "chunk_4": {
            "plus_lines": [
                "     private NameConstraintsExtension nc;",
                "    private boolean jdkCA;",
                "    private boolean hasJdkCABeenChecked;",
                "",
                "    static {",
                "        CertPathHelperImpl.initialize();",
                "    }",
                " "
            ],
            "minus_lines": []
        },
        "chunk_5": {
            "plus_lines": [
                "     }",
                "",
                "    /**",
                "     * Returns true if anchor is a JDK CA (a root CA that is included by",
                "     * default in the cacerts keystore).",
                "     */",
                "    synchronized boolean isJdkCA() {",
                "        if (!hasJdkCABeenChecked) {",
                "            if (trustedCert != null) {",
                "                jdkCA = AnchorCertificates.contains(trustedCert);",
                "            }",
                "            hasJdkCABeenChecked = true;",
                "        }",
                "        return jdkCA;",
                "    }",
                " }"
            ],
            "minus_lines": []
        }
    },
    "pkcs/SignerInfo.java": {
        "chunk_6": {
            "plus_lines": [],
            "minus_lines": [
                " import java.util.ArrayList;",
                "import java.util.Arrays;",
                " import java.util.Collections;"
            ]
        },
        "chunk_7": {
            "plus_lines": [
                " import java.util.Collections;",
                "import java.util.Date;",
                "import java.util.HashMap;",
                "import java.util.HashSet;",
                "import java.util.Map;",
                " import java.util.Set;"
            ],
            "minus_lines": [
                " import java.util.Collections;",
                "import java.util.EnumSet;",
                " import java.util.Set;"
            ]
        },
        "chunk_8": {
            "plus_lines": [],
            "minus_lines": [
                " import sun.security.timestamp.TimestampToken;",
                "import sun.security.util.ConstraintsParameters;",
                " import sun.security.util.Debug;"
            ]
        },
        "chunk_9": {
            "plus_lines": [
                " import sun.security.util.DisabledAlgorithmConstraints;",
                "import sun.security.util.JarConstraintsParameters;",
                " import sun.security.util.KeyUtil;"
            ],
            "minus_lines": []
        },
        "chunk_10": {
            "plus_lines": [
                " import sun.security.util.ObjectIdentifier;",
                "import sun.security.util.SignatureUtil;",
                " import sun.security.x509.AlgorithmId;"
            ],
            "minus_lines": []
        },
        "chunk_11": {
            "plus_lines": [],
            "minus_lines": [
                " import sun.security.x509.KeyUsageExtension;",
                "import sun.security.util.SignatureUtil;",
                " "
            ]
        },
        "chunk_12": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "    // Digest and Signature restrictions",
                "    private static final Set<CryptoPrimitive> DIGEST_PRIMITIVE_SET =",
                "            Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));",
                "",
                "    private static final Set<CryptoPrimitive> SIG_PRIMITIVE_SET =",
                "            Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));",
                "",
                "     private static final DisabledAlgorithmConstraints JAR_DISABLED_CHECK ="
            ]
        },
        "chunk_13": {
            "plus_lines": [
                "     private static final DisabledAlgorithmConstraints JAR_DISABLED_CHECK =",
                "            DisabledAlgorithmConstraints.jarConstraints();",
                " "
            ],
            "minus_lines": [
                "     private static final DisabledAlgorithmConstraints JAR_DISABLED_CHECK =",
                "            new DisabledAlgorithmConstraints(",
                "                    DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);",
                " "
            ]
        },
        "chunk_14": {
            "plus_lines": [
                " ",
                "    /**",
                "     * A map containing the algorithms in this SignerInfo. This is used to",
                "     * avoid checking algorithms to see if they are disabled more than once.",
                "     * The key is the AlgorithmId of the algorithm, and the value is the name of",
                "     * the field or attribute.",
                "     */",
                "    private Map<AlgorithmId, String> algorithms = new HashMap<>();",
                "",
                "     public SignerInfo(X500Name  issuerName,"
            ],
            "minus_lines": []
        },
        "chunk_15": {
            "plus_lines": [
                "         try {",
                "            Timestamp timestamp = getTimestamp();",
                " "
            ],
            "minus_lines": []
        },
        "chunk_16": {
            "plus_lines": [
                " ",
                "            String digestAlgName = digestAlgorithmId.getName();",
                "            algorithms.put(digestAlgorithmId, \"SignerInfo digestAlgorithm field\");",
                " "
            ],
            "minus_lines": [
                " ",
                "            Timestamp timestamp = null;",
                "            try {",
                "                timestamp = getTimestamp();",
                "            } catch (Exception ignore) {",
                "            }",
                "",
                "            ConstraintsParameters cparams =",
                "                    new ConstraintsParameters(timestamp);",
                "            String digestAlgname = getDigestAlgorithmId().getName();",
                " "
            ]
        },
        "chunk_17": {
            "plus_lines": [
                " ",
                "                MessageDigest md = MessageDigest.getInstance(digestAlgName);",
                "                 byte[] computedMessageDigest = md.digest(data);"
            ],
            "minus_lines": [
                " ",
                "                // check that digest algorithm is not restricted",
                "                try {",
                "                    JAR_DISABLED_CHECK.permits(digestAlgname, cparams);",
                "                } catch (CertPathValidatorException e) {",
                "                    throw new SignatureException(e.getMessage(), e);",
                "                }",
                "",
                "                MessageDigest md = MessageDigest.getInstance(digestAlgname);",
                "                 byte[] computedMessageDigest = md.digest(data);"
            ]
        },
        "chunk_18": {
            "plus_lines": [
                " ",
                "                if (!MessageDigest.isEqual(messageDigest, computedMessageDigest)) {",
                "                     return null;"
            ],
            "minus_lines": [
                " ",
                "                if (messageDigest.length != computedMessageDigest.length)",
                "                     return null;"
            ]
        },
        "chunk_19": {
            "plus_lines": [],
            "minus_lines": [
                "                     return null;",
                "                for (int i = 0; i < messageDigest.length; i++) {",
                "                    if (messageDigest[i] != computedMessageDigest[i])",
                "                        return null;",
                "                 }"
            ]
        },
        "chunk_20": {
            "plus_lines": [
                "             // to form signing algorithm",
                "            String encryptionAlgName =",
                "                 getDigestEncryptionAlgorithmId().getName();"
            ],
            "minus_lines": [
                "             // to form signing algorithm",
                "            String encryptionAlgname =",
                "                 getDigestEncryptionAlgorithmId().getName();"
            ]
        },
        "chunk_21": {
            "plus_lines": [
                "             // a signature name",
                "            String tmp = AlgorithmId.getEncAlgFromSigAlg(encryptionAlgName);",
                "            if (tmp != null) encryptionAlgName = tmp;",
                "            String sigAlgName = AlgorithmId.makeSigAlg(",
                "                    digestAlgName, encryptionAlgName);",
                "             try {"
            ],
            "minus_lines": [
                "             // a signature name",
                "            String tmp = AlgorithmId.getEncAlgFromSigAlg(encryptionAlgname);",
                "            if (tmp != null) encryptionAlgname = tmp;",
                "            String algname = AlgorithmId.makeSigAlg(",
                "                    digestAlgname, encryptionAlgname);",
                "",
                "            // check that jar signature algorithm is not restricted",
                "             try {"
            ]
        },
        "chunk_22": {
            "plus_lines": [
                "             try {",
                "                ObjectIdentifier oid = AlgorithmId.get(sigAlgName).getOID();",
                "                AlgorithmId sigAlgId =",
                "                    new AlgorithmId(oid,",
                "                            digestEncryptionAlgorithmId.getParameters());",
                "                algorithms.put(sigAlgId,",
                "                    \"SignerInfo digestEncryptionAlgorithm field\");",
                "            } catch (NoSuchAlgorithmException ignore) {",
                "             }"
            ],
            "minus_lines": [
                "             try {",
                "                JAR_DISABLED_CHECK.permits(algname, cparams);",
                "            } catch (CertPathValidatorException e) {",
                "                throw new SignatureException(e.getMessage(), e);",
                "             }"
            ]
        },
        "chunk_23": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "            // check if the public key is restricted",
                "            if (!JAR_DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {",
                "                throw new SignatureException(\"Public key check failed. \" +",
                "                        \"Disabled key used: \" +",
                "                        KeyUtil.getKeySize(key) + \" bit \" +",
                "                        key.getAlgorithm());",
                "            }",
                "",
                "             if (cert.hasUnsupportedCriticalExtension()) {"
            ]
        },
        "chunk_24": {
            "plus_lines": [
                " ",
                "            Signature sig = Signature.getInstance(sigAlgName);",
                " "
            ],
            "minus_lines": [
                " ",
                "            Signature sig = Signature.getInstance(algname);",
                " "
            ]
        },
        "chunk_25": {
            "plus_lines": [
                "                 SignatureUtil.initVerifyWithParam(sig, key,",
                "                    SignatureUtil.getParamSpec(sigAlgName, ap));",
                "             } catch (ProviderException | InvalidAlgorithmParameterException |"
            ],
            "minus_lines": [
                "                 SignatureUtil.initVerifyWithParam(sig, key,",
                "                    SignatureUtil.getParamSpec(algname, ap));",
                "             } catch (ProviderException | InvalidAlgorithmParameterException |"
            ]
        },
        "chunk_26": {
            "plus_lines": [
                "             }",
                "        } catch (IOException | CertificateException e) {",
                "            throw new SignatureException(\"Error verifying signature\", e);",
                "         }"
            ],
            "minus_lines": [
                "             }",
                "        } catch (IOException e) {",
                "            throw new SignatureException(\"IO error verifying signature:\\n\" +",
                "                                         e.getMessage());",
                "         }"
            ]
        },
        "chunk_27": {
            "plus_lines": [
                "         SignerInfo[] tsa = tsToken.verify(encTsTokenInfo);",
                "        if (tsa == null || tsa.length == 0) {",
                "            throw new SignatureException(\"Unable to verify timestamp\");",
                "        }",
                "         // Expect only one signer"
            ],
            "minus_lines": []
        },
        "chunk_28": {
            "plus_lines": [
                "         verifyTimestamp(tsTokenInfo);",
                "        algorithms.putAll(tsa[0].algorithms);",
                "         // Create a timestamp object"
            ],
            "minus_lines": []
        },
        "chunk_29": {
            "plus_lines": [
                "         throws NoSuchAlgorithmException, SignatureException {",
                "",
                "        AlgorithmId digestAlgId = token.getHashAlgorithm();",
                "        algorithms.put(digestAlgId, \"TimestampToken digestAlgorithm field\");",
                " "
            ],
            "minus_lines": [
                "         throws NoSuchAlgorithmException, SignatureException {",
                "        String digestAlgname = token.getHashAlgorithm().getName();",
                "        // check that algorithm is not restricted",
                "        if (!JAR_DISABLED_CHECK.permits(DIGEST_PRIMITIVE_SET, digestAlgname,",
                "                null)) {",
                "            throw new SignatureException(\"Timestamp token digest check failed. \" +",
                "                    \"Disabled algorithm used: \" + digestAlgname);",
                "        }",
                " "
            ]
        },
        "chunk_30": {
            "plus_lines": [
                " ",
                "        MessageDigest md = MessageDigest.getInstance(digestAlgId.getName());",
                " "
            ],
            "minus_lines": [
                " ",
                "        MessageDigest md =",
                "            MessageDigest.getInstance(digestAlgname);",
                " "
            ]
        },
        "chunk_31": {
            "plus_lines": [
                " ",
                "        if (!MessageDigest.isEqual(token.getHashedMessage(),",
                "             md.digest(encryptedDigest))) {"
            ],
            "minus_lines": [
                " ",
                "        if (!Arrays.equals(token.getHashedMessage(),",
                "             md.digest(encryptedDigest))) {"
            ]
        },
        "chunk_32": {
            "plus_lines": [
                "     }",
                "",
                "    /**",
                "     * Verify all of the algorithms in the array of SignerInfos against the",
                "     * constraints in the jdk.jar.disabledAlgorithms security property.",
                "     *",
                "     * @param infos array of SignerInfos",
                "     * @param params constraint parameters",
                "     * @param name the name of the signer's PKCS7 file",
                "     * @return a set of algorithms that passed the checks and are not disabled",
                "     */",
                "    public static Set<String> verifyAlgorithms(SignerInfo[] infos,",
                "        JarConstraintsParameters params, String name) throws SignatureException {",
                "        Map<AlgorithmId, String> algorithms = new HashMap<>();",
                "        for (SignerInfo info : infos) {",
                "            algorithms.putAll(info.algorithms);",
                "        }",
                "",
                "        Set<String> enabledAlgorithms = new HashSet<>();",
                "        try {",
                "            for (Map.Entry<AlgorithmId, String> algorithm : algorithms.entrySet()) {",
                "                params.setExtendedExceptionMsg(name, algorithm.getValue());",
                "                AlgorithmId algId = algorithm.getKey();",
                "                JAR_DISABLED_CHECK.permits(algId.getName(),",
                "                    algId.getParameters(), params);",
                "                enabledAlgorithms.add(algId.getName());",
                "            }",
                "        } catch (CertPathValidatorException e) {",
                "            throw new SignatureException(e);",
                "        }",
                "        return enabledAlgorithms;",
                "    }",
                " }"
            ],
            "minus_lines": []
        }
    },
    "certpath/AlgorithmChecker.java": {
        "chunk_33": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_34": {
            "plus_lines": [],
            "minus_lines": [
                " import java.security.CryptoPrimitive;",
                "import java.security.Timestamp;",
                "import java.security.cert.CertPathValidator;",
                " import java.util.Collection;"
            ]
        },
        "chunk_35": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "import sun.security.util.AnchorCertificates;",
                " import sun.security.util.ConstraintsParameters;"
            ]
        },
        "chunk_36": {
            "plus_lines": [
                " import sun.security.validator.Validator;",
                "import sun.security.x509.AlgorithmId;",
                " import sun.security.x509.X509CertImpl;"
            ],
            "minus_lines": []
        },
        "chunk_37": {
            "plus_lines": [],
            "minus_lines": [
                " import sun.security.x509.X509CRLImpl;",
                "import sun.security.x509.AlgorithmId;",
                " "
            ]
        },
        "chunk_38": {
            "plus_lines": [
                "     private final PublicKey trustedPubKey;",
                "    private final Date date;",
                "     private PublicKey prevPubKey;"
            ],
            "minus_lines": [
                "     private final PublicKey trustedPubKey;",
                "    private final Date pkixdate;",
                "     private PublicKey prevPubKey;"
            ]
        },
        "chunk_39": {
            "plus_lines": [],
            "minus_lines": [
                "     private PublicKey prevPubKey;",
                "    private final Timestamp jarTimestamp;",
                "     private final String variant;"
            ]
        },
        "chunk_40": {
            "plus_lines": [
                "     private final String variant;",
                "    private TrustAnchor anchor;",
                " "
            ],
            "minus_lines": []
        },
        "chunk_41": {
            "plus_lines": [
                "     private static final DisabledAlgorithmConstraints",
                "        certPathDefaultConstraints =",
                "            DisabledAlgorithmConstraints.certPathConstraints();",
                " "
            ],
            "minus_lines": [
                "     private static final DisabledAlgorithmConstraints",
                "        certPathDefaultConstraints = new DisabledAlgorithmConstraints(",
                "            DisabledAlgorithmConstraints.PROPERTY_CERTPATH_DISABLED_ALGS);",
                "",
                "    // If there is no \"cacerts\" keyword, then disable anchor checking",
                "    private static final boolean publicCALimits =",
                "            certPathDefaultConstraints.checkProperty(\"jdkCA\");",
                "",
                "    // If anchor checking enabled, this will be true if the trust anchor",
                "    // has a match in the cacerts file",
                "    private boolean trustedMatch = false;",
                " "
            ]
        },
        "chunk_42": {
            "plus_lines": [
                "     /**",
                "     * Create a new {@code AlgorithmChecker} with the given",
                "     * {@code TrustAnchor} and {@code String} variant.",
                "      *"
            ],
            "minus_lines": [
                "     /**",
                "     * Create a new {@code AlgorithmChecker} with the given algorithm",
                "     * given {@code TrustAnchor} and {@code String} variant.",
                "      *"
            ]
        },
        "chunk_43": {
            "plus_lines": [
                "      *     certificate",
                "     * @param variant the Validator variant of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ],
            "minus_lines": [
                "      *     certificate",
                "     * @param variant is the Validator variants of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ]
        },
        "chunk_44": {
            "plus_lines": [
                "     public AlgorithmChecker(TrustAnchor anchor, String variant) {",
                "        this(anchor, certPathDefaultConstraints, null, variant);",
                "     }"
            ],
            "minus_lines": [
                "     public AlgorithmChecker(TrustAnchor anchor, String variant) {",
                "        this(anchor, certPathDefaultConstraints, null, null, variant);",
                "     }"
            ]
        },
        "chunk_45": {
            "plus_lines": [
                "      * Create a new {@code AlgorithmChecker} with the given",
                "     * {@code AlgorithmConstraints} and {@code String} variant.",
                "      *"
            ],
            "minus_lines": [
                "      * Create a new {@code AlgorithmChecker} with the given",
                "     * {@code AlgorithmConstraints}, {@code Timestamp}, and {@code String}",
                "     * variant.",
                "      *"
            ]
        },
        "chunk_46": {
            "plus_lines": [
                "      * Note that this constructor can initialize a variation of situations where",
                "     * the AlgorithmConstraints or Variant maybe known.",
                "      *"
            ],
            "minus_lines": [
                "      * Note that this constructor can initialize a variation of situations where",
                "     * the AlgorithmConstraints, Timestamp, or Variant maybe known.",
                "      *"
            ]
        },
        "chunk_47": {
            "plus_lines": [
                "      * @param constraints the algorithm constraints (or null)",
                "     * @param variant the Validator variant of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ],
            "minus_lines": [
                "      * @param constraints the algorithm constraints (or null)",
                "     * @param jarTimestamp Timestamp passed for JAR timestamp constraint",
                "     *                     checking. Set to null if not applicable.",
                "     * @param variant is the Validator variants of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ]
        },
        "chunk_48": {
            "plus_lines": [
                "      */",
                "    public AlgorithmChecker(AlgorithmConstraints constraints, String variant) {",
                "        this(null, constraints, null, variant);",
                "     }"
            ],
            "minus_lines": [
                "      */",
                "    public AlgorithmChecker(AlgorithmConstraints constraints,",
                "            Timestamp jarTimestamp, String variant) {",
                "        this(null, constraints, null, jarTimestamp, variant);",
                "     }"
            ]
        },
        "chunk_49": {
            "plus_lines": [
                "      * Create a new {@code AlgorithmChecker} with the",
                "     * given {@code TrustAnchor}, {@code AlgorithmConstraints}, {@code Date},",
                "     * and {@code String} variant.",
                "      *"
            ],
            "minus_lines": [
                "      * Create a new {@code AlgorithmChecker} with the",
                "     * given {@code TrustAnchor}, {@code AlgorithmConstraints},",
                "     * {@code Timestamp}, and {@code String} variant.",
                "      *"
            ]
        },
        "chunk_50": {
            "plus_lines": [
                "      * @param constraints the algorithm constraints (or null)",
                "     * @param date the date specified by the PKIXParameters date, or the",
                "     *             JAR timestamp if jar files are being validated and the",
                "     *             JAR is timestamped. May be null if no timestamp or",
                "     *             PKIXParameter date is set.",
                "     * @param variant the Validator variant of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ],
            "minus_lines": [
                "      * @param constraints the algorithm constraints (or null)",
                "     * @param pkixdate The date specified by the PKIXParameters date.  If the",
                "     *                 PKIXParameters is null, the current date is used.  This",
                "     *                 should be null when jar files are being checked.",
                "     * @param jarTimestamp Timestamp passed for JAR timestamp constraint",
                "     *                     checking. Set to null if not applicable.",
                "     * @param variant is the Validator variants of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ]
        },
        "chunk_51": {
            "plus_lines": [
                "     public AlgorithmChecker(TrustAnchor anchor,",
                "            AlgorithmConstraints constraints, Date date, String variant) {",
                " "
            ],
            "minus_lines": [
                "     public AlgorithmChecker(TrustAnchor anchor,",
                "            AlgorithmConstraints constraints, Date pkixdate,",
                "            Timestamp jarTimestamp, String variant) {",
                " "
            ]
        },
        "chunk_52": {
            "plus_lines": [],
            "minus_lines": [
                "                 this.trustedPubKey = anchor.getTrustedCert().getPublicKey();",
                "                // Check for anchor certificate restrictions",
                "                trustedMatch = checkFingerprint(anchor.getTrustedCert());",
                "                if (trustedMatch && debug != null) {",
                "                    debug.println(\"trustedMatch = true\");",
                "                }",
                "             } else {"
            ]
        },
        "chunk_53": {
            "plus_lines": [
                "             }",
                "            this.anchor = anchor;",
                "         } else {"
            ],
            "minus_lines": []
        },
        "chunk_54": {
            "plus_lines": [],
            "minus_lines": [
                "             this.trustedPubKey = null;",
                "            if (debug != null) {",
                "                debug.println(\"TrustAnchor is null, trustedMatch is false.\");",
                "            }",
                "         }"
            ]
        },
        "chunk_55": {
            "plus_lines": [
                "                 constraints);",
                "        this.date = date;",
                "         this.variant = (variant == null ? Validator.VAR_GENERIC : variant);"
            ],
            "minus_lines": [
                "                 constraints);",
                "        // If we are checking jar files, set pkixdate the same as the timestamp",
                "        // for certificate checking",
                "        this.pkixdate = (jarTimestamp != null ? jarTimestamp.getTimestamp() :",
                "                pkixdate);",
                "        this.jarTimestamp = jarTimestamp;",
                "         this.variant = (variant == null ? Validator.VAR_GENERIC : variant);"
            ]
        },
        "chunk_56": {
            "plus_lines": [
                "      *             either the PKIXParameters date or null for the current date.",
                "     * @param variant the Validator variant of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ],
            "minus_lines": [
                "      *             either the PKIXParameters date or null for the current date.",
                "     * @param variant is the Validator variants of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ]
        },
        "chunk_57": {
            "plus_lines": [
                "     public AlgorithmChecker(TrustAnchor anchor, Date pkixdate, String variant) {",
                "        this(anchor, certPathDefaultConstraints, pkixdate, variant);",
                "     }"
            ],
            "minus_lines": [
                "     public AlgorithmChecker(TrustAnchor anchor, Date pkixdate, String variant) {",
                "        this(anchor, certPathDefaultConstraints, pkixdate, null, variant);",
                "    }",
                "",
                "    // Check this 'cert' for restrictions in the AnchorCertificates",
                "    // trusted certificates list",
                "    private static boolean checkFingerprint(X509Certificate cert) {",
                "        if (!publicCALimits) {",
                "            return false;",
                "        }",
                "",
                "        if (debug != null) {",
                "            debug.println(\"AlgorithmChecker.contains: \" + cert.getSigAlgName());",
                "        }",
                "        return AnchorCertificates.contains(cert);",
                "     }"
            ]
        },
        "chunk_58": {
            "plus_lines": [
                "         ConstraintsParameters cp =",
                "            new CertPathConstraintsParameters(x509Cert, variant,",
                "                    anchor, date);",
                " "
            ],
            "minus_lines": [
                "         ConstraintsParameters cp =",
                "                new ConstraintsParameters((X509Certificate)cert,",
                "                        trustedMatch, pkixdate, jarTimestamp, variant);",
                " "
            ]
        },
        "chunk_59": {
            "plus_lines": [
                "         if (constraints instanceof DisabledAlgorithmConstraints) {",
                "            ((DisabledAlgorithmConstraints)constraints).permits(currSigAlg,",
                "                currSigAlgParams, cp);",
                "             // DisabledAlgorithmsConstraints does not check primitives, so key"
            ],
            "minus_lines": [
                "         if (constraints instanceof DisabledAlgorithmConstraints) {",
                "            ((DisabledAlgorithmConstraints)constraints).permits(currSigAlg, cp);",
                "             // DisabledAlgorithmsConstraints does not check primitives, so key"
            ]
        },
        "chunk_60": {
            "plus_lines": [
                "             // Perform the default constraints checking anyway.",
                "            certPathDefaultConstraints.permits(currSigAlg, currSigAlgParams, cp);",
                "             // Call locally set constraints to check key with primitives."
            ],
            "minus_lines": [
                "             // Perform the default constraints checking anyway.",
                "            certPathDefaultConstraints.permits(currSigAlg, cp);",
                "             // Call locally set constraints to check key with primitives."
            ]
        },
        "chunk_61": {
            "plus_lines": [],
            "minus_lines": [
                "                 prevPubKey = anchor.getTrustedCert().getPublicKey();",
                "                // Check for anchor certificate restrictions",
                "                trustedMatch = checkFingerprint(anchor.getTrustedCert());",
                "                if (trustedMatch && debug != null) {",
                "                    debug.println(\"trustedMatch = true\");",
                "                }",
                "             } else {"
            ]
        },
        "chunk_62": {
            "plus_lines": [
                "             }",
                "            this.anchor = anchor;",
                "         }"
            ],
            "minus_lines": []
        },
        "chunk_63": {
            "plus_lines": [
                "      * @param crl the target CRL",
                "     * @param variant the Validator variant of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ],
            "minus_lines": [
                "      * @param crl the target CRL",
                "     * @param variant is the Validator variants of the operation. A null value",
                "      *                passed will set it to Validator.GENERIC."
            ]
        },
        "chunk_64": {
            "plus_lines": [
                "      *                passed will set it to Validator.GENERIC.",
                "     * @param anchor the trust anchor selected to validate the CRL issuer",
                "      */"
            ],
            "minus_lines": []
        },
        "chunk_65": {
            "plus_lines": [
                "      */",
                "    static void check(PublicKey key, X509CRL crl, String variant,",
                "                      TrustAnchor anchor) throws CertPathValidatorException {",
                " "
            ],
            "minus_lines": [
                "      */",
                "    static void check(PublicKey key, X509CRL crl, String variant)",
                "                        throws CertPathValidatorException {",
                " "
            ]
        },
        "chunk_66": {
            "plus_lines": [
                "         AlgorithmId algorithmId = x509CRLImpl.getSigAlgId();",
                "        check(key, algorithmId, variant, anchor);",
                "     }"
            ],
            "minus_lines": [
                "         AlgorithmId algorithmId = x509CRLImpl.getSigAlgId();",
                "        check(key, algorithmId, variant);",
                "     }"
            ]
        },
        "chunk_67": {
            "plus_lines": [
                "      * @param algorithmId signature algorithm Algorithm ID",
                "     * @param variant the Validator variant of the operation. A null",
                "     *                value passed will set it to Validator.GENERIC.",
                "     * @param anchor the trust anchor selected to validate the public key",
                "      */"
            ],
            "minus_lines": [
                "      * @param algorithmId signature algorithm Algorithm ID",
                "     * @param variant is the Validator variants of the operation. A null value",
                "     *                passed will set it to Validator.GENERIC.",
                "      */"
            ]
        },
        "chunk_68": {
            "plus_lines": [
                "      */",
                "    static void check(PublicKey key, AlgorithmId algorithmId, String variant,",
                "                      TrustAnchor anchor) throws CertPathValidatorException {",
                " "
            ],
            "minus_lines": [
                "      */",
                "    static void check(PublicKey key, AlgorithmId algorithmId, String variant)",
                "                        throws CertPathValidatorException {",
                "        String sigAlgName = algorithmId.getName();",
                "        AlgorithmParameters sigAlgParams = algorithmId.getParameters();",
                " "
            ]
        },
        "chunk_69": {
            "plus_lines": [
                " ",
                "        certPathDefaultConstraints.permits(algorithmId.getName(),",
                "            algorithmId.getParameters(),",
                "            new CertPathConstraintsParameters(key, variant, anchor));",
                "     }"
            ],
            "minus_lines": [
                " ",
                "        certPathDefaultConstraints.permits(new ConstraintsParameters(",
                "                sigAlgName, sigAlgParams, key, variant));",
                "     }"
            ]
        }
    },
    "certpath/CertPathConstraintsParameters.java": {
        "chunk_70": {
            "plus_lines": [
                "@@ -0,0 +1,127 @@",
                "/*",
                " * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.",
                " * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.",
                " *",
                " * This code is free software; you can redistribute it and/or modify it",
                " * under the terms of the GNU General Public License version 2 only, as",
                " * published by the Free Software Foundation.  Oracle designates this",
                " * particular file as subject to the \"Classpath\" exception as provided",
                " * by Oracle in the LICENSE file that accompanied this code.",
                " *",
                " * This code is distributed in the hope that it will be useful, but WITHOUT",
                " * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or",
                " * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License",
                " * version 2 for more details (a copy is included in the LICENSE file that",
                " * accompanied this code).",
                " *",
                " * You should have received a copy of the GNU General Public License version",
                " * 2 along with this work; if not, write to the Free Software Foundation,",
                " * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.",
                " *",
                " * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA",
                " * or visit www.oracle.com if you need additional information or have any",
                " * questions.",
                " */",
                "",
                "package sun.security.provider.certpath;",
                "",
                "import java.security.Key;",
                "import java.security.cert.TrustAnchor;",
                "import java.security.cert.X509Certificate;",
                "import java.util.Date;",
                "import java.util.Set;",
                "import java.util.Collections;",
                "",
                "import sun.security.util.ConstraintsParameters;",
                "import sun.security.validator.Validator;",
                "",
                "/**",
                " * This class contains parameters for checking certificates against",
                " * constraints specified in the jdk.certpath.disabledAlgorithms security",
                " * property.",
                " */",
                "class CertPathConstraintsParameters implements ConstraintsParameters {",
                "    // The public key of the certificate",
                "    private final Key key;",
                "    // The certificate's trust anchor which will be checked against the",
                "    // jdkCA constraint, if specified.",
                "    private final TrustAnchor anchor;",
                "    // The PKIXParameter validity date or the timestamp of the signed JAR",
                "    // file, if this chain is associated with a timestamped signed JAR.",
                "    private final Date date;",
                "    // The variant or usage of this certificate",
                "    private final String variant;",
                "    // The certificate being checked (may be null if a CRL or OCSPResponse is",
                "    // being checked)",
                "    private final X509Certificate cert;",
                "",
                "    public CertPathConstraintsParameters(X509Certificate cert,",
                "            String variant, TrustAnchor anchor, Date date) {",
                "        this(cert.getPublicKey(), variant, anchor, date, cert);",
                "    }",
                "",
                "    public CertPathConstraintsParameters(Key key, String variant,",
                "            TrustAnchor anchor) {",
                "        this(key, variant, anchor, null, null);",
                "    }",
                "",
                "    private CertPathConstraintsParameters(Key key, String variant,",
                "            TrustAnchor anchor, Date date, X509Certificate cert) {",
                "        this.key = key;",
                "        this.variant = (variant == null ? Validator.VAR_GENERIC : variant);",
                "        this.anchor = anchor;",
                "        this.date = date;",
                "        this.cert = cert;",
                "    }",
                "",
                "    @Override",
                "    public boolean anchorIsJdkCA() {",
                "        return CertPathHelper.isJdkCA(anchor);",
                "    }",
                "",
                "    @Override",
                "    public Set<Key> getKeys() {",
                "        return (key == null) ? Collections.emptySet()",
                "                             : Collections.singleton(key);",
                "    }",
                "",
                "    @Override",
                "    public Date getDate() {",
                "        return date;",
                "    }",
                "",
                "    @Override",
                "    public String getVariant() {",
                "        return variant;",
                "    }",
                "",
                "    @Override",
                "    public String extendedExceptionMsg() {",
                "        return (cert == null ? \".\"",
                "                 : \" used with certificate: \" +",
                "                   cert.getSubjectX500Principal());",
                "    }",
                "",
                "    @Override",
                "    public String toString() {",
                "        StringBuilder sb = new StringBuilder(\"[\\n\");",
                "        sb.append(\"\\n  Variant: \").append(variant);",
                "        if (anchor != null) {",
                "            sb.append(\"\\n  Anchor: \").append(anchor);",
                "        }",
                "        if (cert != null) {",
                "            sb.append(\"\\n  Cert Issuer: \")",
                "              .append(cert.getIssuerX500Principal());",
                "            sb.append(\"\\n  Cert Subject: \")",
                "              .append(cert.getSubjectX500Principal());",
                "        }",
                "        if (key != null) {",
                "            sb.append(\"\\n  Key: \").append(key.getAlgorithm());",
                "        }",
                "        if (date != null) {",
                "            sb.append(\"\\n  Date: \").append(date);",
                "        }",
                "        sb.append(\"\\n]\");",
                "        return sb.toString();",
                "    }",
                "}"
            ],
            "minus_lines": []
        }
    },
    "certpath/CertPathHelper.java": {
        "chunk_71": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_72": {
            "plus_lines": [
                " ",
                "import java.security.cert.TrustAnchor;",
                " import java.security.cert.X509CertSelector;"
            ],
            "minus_lines": []
        },
        "chunk_73": {
            "plus_lines": [
                " /**",
                " * Helper class that allows access to JDK specific known-public methods in the",
                "  * java.security.cert package. It relies on a subclass in the"
            ],
            "minus_lines": [
                " /**",
                " * Helper class that allows access to Sun specific known-public methods in the",
                "  * java.security.cert package. It relies on a subclass in the"
            ]
        },
        "chunk_74": {
            "plus_lines": [
                " ",
                "    protected abstract boolean implIsJdkCA(TrustAnchor anchor);",
                "",
                "     static void setPathToNames(X509CertSelector sel,"
            ],
            "minus_lines": []
        },
        "chunk_75": {
            "plus_lines": [
                "     }",
                "",
                "    public static boolean isJdkCA(TrustAnchor anchor) {",
                "        return (anchor == null) ? false : instance.implIsJdkCA(anchor);",
                "    }",
                " }"
            ],
            "minus_lines": []
        }
    },
    "certpath/DistributionPointFetcher.java": {
        "chunk_76": {
            "plus_lines": [
                "         return getCRLs(selector, signFlag, prevKey, null, provider, certStores,",
                "                reasonsMask, trustAnchors, validity, variant, null);",
                "     }"
            ],
            "minus_lines": [
                "         return getCRLs(selector, signFlag, prevKey, null, provider, certStores,",
                "                reasonsMask, trustAnchors, validity, variant);",
                "     }"
            ]
        },
        "chunk_77": {
            "plus_lines": [
                "     {",
                "        if (trustAnchors.isEmpty()) {",
                "            throw new CertStoreException(",
                "                \"at least one TrustAnchor must be specified\");",
                "        }",
                "        TrustAnchor anchor = trustAnchors.iterator().next();",
                "         return getCRLs(selector, signFlag, prevKey, null, provider, certStores,"
            ],
            "minus_lines": []
        },
        "chunk_78": {
            "plus_lines": [
                "         return getCRLs(selector, signFlag, prevKey, null, provider, certStores,",
                "                reasonsMask, trustAnchors, validity,",
                "                Validator.VAR_PLUGIN_CODE_SIGNING, anchor);",
                "     }"
            ],
            "minus_lines": [
                "         return getCRLs(selector, signFlag, prevKey, null, provider, certStores,",
                "                reasonsMask, trustAnchors, validity, Validator.VAR_GENERIC);",
                "     }"
            ]
        },
        "chunk_79": {
            "plus_lines": [
                "                                               Date validity,",
                "                                              String variant,",
                "                                              TrustAnchor anchor)",
                "         throws CertStoreException"
            ],
            "minus_lines": [
                "                                               Date validity,",
                "                                              String variant)",
                "         throws CertStoreException"
            ]
        },
        "chunk_80": {
            "plus_lines": [
                "                     point, reasonsMask, signFlag, prevKey, prevCert, provider,",
                "                    certStores, trustAnchors, validity, variant, anchor);",
                "                 results.addAll(crls);"
            ],
            "minus_lines": [
                "                     point, reasonsMask, signFlag, prevKey, prevCert, provider,",
                "                    certStores, trustAnchors, validity, variant);",
                "                 results.addAll(crls);"
            ]
        },
        "chunk_81": {
            "plus_lines": [
                "         String provider, List<CertStore> certStores,",
                "        Set<TrustAnchor> trustAnchors, Date validity, String variant,",
                "        TrustAnchor anchor)",
                "             throws CertStoreException {"
            ],
            "minus_lines": [
                "         String provider, List<CertStore> certStores,",
                "        Set<TrustAnchor> trustAnchors, Date validity, String variant)",
                "             throws CertStoreException {"
            ]
        },
        "chunk_82": {
            "plus_lines": [
                "                         reasonsMask, signFlag, prevKey, prevCert, provider,",
                "                        trustAnchors, certStores, validity, variant, anchor)) {",
                "                     crls.add(crl);"
            ],
            "minus_lines": [
                "                         reasonsMask, signFlag, prevKey, prevCert, provider,",
                "                        trustAnchors, certStores, validity, variant)) {",
                "                     crls.add(crl);"
            ]
        },
        "chunk_83": {
            "plus_lines": [
                "         Set<TrustAnchor> trustAnchors, List<CertStore> certStores,",
                "        Date validity, String variant, TrustAnchor anchor)",
                "        throws CRLException, IOException {",
                " "
            ],
            "minus_lines": [
                "         Set<TrustAnchor> trustAnchors, List<CertStore> certStores,",
                "        Date validity, String variant) throws CRLException, IOException {",
                " "
            ]
        },
        "chunk_84": {
            "plus_lines": [
                "         try {",
                "            AlgorithmChecker.check(prevKey, crl, variant, anchor);",
                "         } catch (CertPathValidatorException cpve) {"
            ],
            "minus_lines": [
                "         try {",
                "            AlgorithmChecker.check(prevKey, crl, variant);",
                "         } catch (CertPathValidatorException cpve) {"
            ]
        }
    },
    "certpath/OCSP.java": {
        "chunk_85": {
            "plus_lines": [
                "         return check(cert, issuerCert, responderURI, responderCert, date,",
                "                     Collections.<Extension>emptyList(),",
                "                     Validator.VAR_PLUGIN_CODE_SIGNING);",
                "     }"
            ],
            "minus_lines": [
                "         return check(cert, issuerCert, responderURI, responderCert, date,",
                "                     Collections.<Extension>emptyList(), Validator.VAR_GENERIC);",
                "     }"
            ]
        }
    },
    "certpath/OCSPResponse.java": {
        "chunk_86": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_87": {
            "plus_lines": [
                "         // Check whether the signer cert returned by the responder is trusted",
                "        boolean signedByTrustedResponder = false;",
                "         if (signerCert != null) {"
            ],
            "minus_lines": []
        },
        "chunk_88": {
            "plus_lines": [
                "             } else if (signerCert.equals(responderCert)) {",
                "                signedByTrustedResponder = true;",
                "                 if (debug != null) {"
            ],
            "minus_lines": []
        },
        "chunk_89": {
            "plus_lines": [
                "             // \"jdk.certpath.disabledAlgorithms\".",
                "            AlgorithmChecker.check(signerCert.getPublicKey(), sigAlgId, variant,",
                "                    signedByTrustedResponder",
                "                        ? new TrustAnchor(responderCert, null)",
                "                        : issuerInfo.getAnchor());",
                " "
            ],
            "minus_lines": [
                "             // \"jdk.certpath.disabledAlgorithms\".",
                "            AlgorithmChecker.check(signerCert.getPublicKey(), sigAlgId, variant);",
                " "
            ]
        }
    },
    "certpath/PKIX.java": {
        "chunk_90": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_91": {
            "plus_lines": [
                " import sun.security.util.Debug;",
                "import sun.security.validator.Validator;",
                " "
            ],
            "minus_lines": []
        },
        "chunk_92": {
            "plus_lines": [
                "         private Timestamp timestamp;",
                "        private String variant = Validator.VAR_GENERIC;",
                " "
            ],
            "minus_lines": [
                "         private Timestamp timestamp;",
                "        private String variant;",
                " "
            ]
        },
        "chunk_93": {
            "plus_lines": [
                "             if (!gotDate) {",
                "                // use timestamp if checking signed code that is",
                "                // timestamped, otherwise use date parameter",
                "                if (timestamp != null &&",
                "                    (variant.equals(Validator.VAR_CODE_SIGNING) ||",
                "                     variant.equals(Validator.VAR_PLUGIN_CODE_SIGNING))) {",
                "                    date = timestamp.getTimestamp();",
                "                } else {",
                "                    date = params.getDate();",
                "                    if (date == null)",
                "                        date = new Date();",
                "                }",
                "                 gotDate = true;"
            ],
            "minus_lines": [
                "             if (!gotDate) {",
                "                date = params.getDate();",
                "                if (date == null)",
                "                    date = new Date();",
                "                 gotDate = true;"
            ]
        },
        "chunk_94": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "        Timestamp timestamp() {",
                "            return timestamp;",
                "        }",
                "",
                "         String variant() {"
            ]
        }
    },
    "certpath/PKIXCertPathValidator.java": {
        "chunk_95": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_96": {
            "plus_lines": [],
            "minus_lines": [
                " import sun.security.provider.certpath.PKIX.ValidatorParams;",
                "import sun.security.validator.Validator;",
                " import sun.security.x509.X509CertImpl;"
            ]
        },
        "chunk_97": {
            "plus_lines": [
                "         certPathCheckers.add(new AlgorithmChecker(anchor, null, params.date(),",
                "                params.variant()));",
                "         certPathCheckers.add(new KeyChecker(certPathLen,"
            ],
            "minus_lines": [
                "         certPathCheckers.add(new AlgorithmChecker(anchor, null, params.date(),",
                "                params.timestamp(), params.variant()));",
                "         certPathCheckers.add(new KeyChecker(certPathLen,"
            ]
        },
        "chunk_98": {
            "plus_lines": [
                " ",
                "        BasicChecker bc = new BasicChecker(anchor, params.date(),",
                "                                            params.sigProvider(), false);"
            ],
            "minus_lines": [
                " ",
                "        // the time that the certificate validity period should be",
                "        // checked against",
                "        Date timeToCheck = null;",
                "        // use timestamp if checking signed code that is timestamped, otherwise",
                "        // use date parameter from PKIXParameters",
                "        if ((params.variant() == Validator.VAR_CODE_SIGNING ||",
                "             params.variant() == Validator.VAR_PLUGIN_CODE_SIGNING) &&",
                "             params.timestamp() != null) {",
                "            timeToCheck = params.timestamp().getTimestamp();",
                "        } else {",
                "            timeToCheck = params.date();",
                "        }",
                "        BasicChecker bc = new BasicChecker(anchor, timeToCheck,",
                "                                            params.sigProvider(), false);"
            ]
        }
    },
    "certpath/RevocationChecker.java": {
        "chunk_99": {
            "plus_lines": [
                "                             params.sigProvider(), certStores, reasonsMask,",
                "                            anchors, null, params.variant(), anchor));",
                "                 }"
            ],
            "minus_lines": [
                "                             params.sigProvider(), certStores, reasonsMask,",
                "                            anchors, null, params.variant()));",
                "                 }"
            ]
        },
        "chunk_100": {
            "plus_lines": [
                "                             prevKey, null, params.sigProvider(), anchors,",
                "                            certStores, params.date(), params.variant(), anchor))",
                "                     {"
            ],
            "minus_lines": [
                "                             prevKey, null, params.sigProvider(), anchors,",
                "                            certStores, params.date(), params.variant()))",
                "                     {"
            ]
        }
    },
    "ssl/SSLContextImpl.java": {
        "chunk_101": {
            "plus_lines": [
                "                 AlgorithmChecker checker =",
                "                    new AlgorithmChecker(constraints,",
                "                             (checkClientTrusted ? Validator.VAR_TLS_CLIENT :"
            ],
            "minus_lines": [
                "                 AlgorithmChecker checker =",
                "                    new AlgorithmChecker(constraints, null,",
                "                             (checkClientTrusted ? Validator.VAR_TLS_CLIENT :"
            ]
        }
    },
    "ssl/X509KeyManagerImpl.java": {
        "chunk_102": {
            "plus_lines": [
                " ",
                "        AlgorithmChecker checker = new AlgorithmChecker(constraints, variant);",
                "         try {"
            ],
            "minus_lines": [
                " ",
                "        AlgorithmChecker checker =",
                "                new AlgorithmChecker(constraints, null, variant);",
                "         try {"
            ]
        }
    },
    "util/AnchorCertificates.java": {
        "chunk_103": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_104": {
            "plus_lines": [
                " import java.util.Set;",
                "import javax.security.auth.x500.X500Principal;",
                " "
            ],
            "minus_lines": []
        },
        "chunk_105": {
            "plus_lines": [
                "     private static Set<String> certs = Collections.emptySet();",
                "    private static Set<X500Principal> certIssuers = Collections.emptySet();",
                " "
            ],
            "minus_lines": []
        },
        "chunk_106": {
            "plus_lines": [
                "                         certs = new HashSet<>();",
                "                        certIssuers = new HashSet<>();",
                "                         Enumeration<String> list = cacerts.aliases();"
            ],
            "minus_lines": []
        },
        "chunk_107": {
            "plus_lines": [],
            "minus_lines": [
                "                         Enumeration<String> list = cacerts.aliases();",
                "                        String alias;",
                "                         while (list.hasMoreElements()) {"
            ]
        },
        "chunk_108": {
            "plus_lines": [
                "                         while (list.hasMoreElements()) {",
                "                            String alias = list.nextElement();",
                "                             // Check if this cert is labeled a trust anchor."
            ],
            "minus_lines": [
                "                         while (list.hasMoreElements()) {",
                "                            alias = list.nextElement();",
                "                             // Check if this cert is labeled a trust anchor."
            ]
        },
        "chunk_109": {
            "plus_lines": [
                "                                 certs.add(X509CertImpl.getFingerprint(HASH, cert));",
                "                                certIssuers.add(cert.getSubjectX500Principal());",
                "                             }"
            ],
            "minus_lines": []
        },
        "chunk_110": {
            "plus_lines": [
                "     /**",
                "     * Checks if a certificate is a JDK trust anchor.",
                "      *"
            ],
            "minus_lines": [
                "     /**",
                "     * Checks if a certificate is a trust anchor.",
                "      *"
            ]
        },
        "chunk_111": {
            "plus_lines": [
                "      * @param cert the certificate to check",
                "     * @return true if the certificate is a JDK trust anchor",
                "      */"
            ],
            "minus_lines": [
                "      * @param cert the certificate to check",
                "     * @return true if the certificate is trusted.",
                "      */"
            ]
        },
        "chunk_112": {
            "plus_lines": [
                " ",
                "    /**",
                "     * Checks if a JDK trust anchor is the issuer of a certificate.",
                "     *",
                "     * @param cert the certificate to check",
                "     * @return true if the certificate is issued by a trust anchor",
                "     */",
                "    public static boolean issuerOf(X509Certificate cert) {",
                "        return certIssuers.contains(cert.getIssuerX500Principal());",
                "    }",
                "",
                "     private AnchorCertificates() {}"
            ],
            "minus_lines": []
        }
    },
    "util/ConstraintsParameters.java": {
        "chunk_113": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "import sun.security.validator.Validator;",
                "",
                "import java.security.AlgorithmParameters;",
                " import java.security.Key;"
            ]
        },
        "chunk_114": {
            "plus_lines": [],
            "minus_lines": [
                " import java.security.Key;",
                "import java.security.Timestamp;",
                "import java.security.cert.X509Certificate;",
                "import java.security.interfaces.ECKey;",
                " import java.util.Date;"
            ]
        },
        "chunk_115": {
            "plus_lines": [
                " import java.util.Date;",
                "import java.util.Set;",
                " "
            ],
            "minus_lines": []
        },
        "chunk_116": {
            "plus_lines": [
                " /**",
                " * This interface contains parameters for checking against constraints that",
                " * extend past the publicly available parameters in",
                " * java.security.AlgorithmConstraints.",
                "  */"
            ],
            "minus_lines": [
                " /**",
                " * This class contains parameters for checking against constraints that extend",
                " * past the publicly available parameters in java.security.AlgorithmConstraints.",
                "",
                " * This is currently on passed between  between PKIX, AlgorithmChecker,",
                " * and DisabledAlgorithmConstraints.",
                "  */"
            ]
        },
        "chunk_117": {
            "plus_lines": [
                "  */",
                "public interface ConstraintsParameters {",
                " "
            ],
            "minus_lines": [
                "  */",
                "public class ConstraintsParameters {",
                "    /*",
                "     * The below 3 values are used the same as the permit() methods",
                "     * published in java.security.AlgorithmConstraints.",
                "     */",
                "    // Algorithm string to be checked against constraints",
                "    private final String algorithm;",
                "    // AlgorithmParameters to the algorithm being checked",
                "    private final AlgorithmParameters algParams;",
                "    // Key being checked against constraints",
                "    private final Key key;",
                "",
                "    /*",
                "     * New values that are checked against constraints that the current public",
                "     * API does not support.",
                "     */",
                "    // A certificate being passed to check against constraints.",
                "    private final X509Certificate cert;",
                "    // This is true if the trust anchor in the certificate chain matches a cert",
                "    // in AnchorCertificates",
                "    private final boolean trustedMatch;",
                "    // PKIXParameter date",
                "    private final Date pkixDate;",
                "    // Timestamp of the signed JAR file",
                "    private final Timestamp jarTimestamp;",
                "    private final String variant;",
                "    // Named Curve",
                "    private final String[] curveStr;",
                "    private static final String[] EMPTYLIST = new String[0];",
                " "
            ]
        },
        "chunk_118": {
            "plus_lines": [
                " ",
                "    /**",
                "     * Returns true if a certificate chains back to a trusted JDK root CA.",
                "     */",
                "    boolean anchorIsJdkCA();",
                " "
            ],
            "minus_lines": [
                " ",
                "    public ConstraintsParameters(X509Certificate c, boolean match,",
                "            Date pkixdate, Timestamp jarTime, String variant) {",
                "        cert = c;",
                "        trustedMatch = match;",
                "        pkixDate = pkixdate;",
                "        jarTimestamp = jarTime;",
                "        this.variant = (variant == null ? Validator.VAR_GENERIC : variant);",
                "        algorithm = null;",
                "        algParams = null;",
                "        key = null;",
                "        if (c != null) {",
                "            curveStr = getNamedCurveFromKey(c.getPublicKey());",
                "        } else {",
                "            curveStr = EMPTYLIST;",
                "        }",
                "    }",
                " "
            ]
        },
        "chunk_119": {
            "plus_lines": [
                " ",
                "    /**",
                "     * Returns the set of keys that should be checked against the",
                "     * constraints, or an empty set if there are no keys to be checked.",
                "     */",
                "    Set<Key> getKeys();",
                " "
            ],
            "minus_lines": [
                " ",
                "    public ConstraintsParameters(String algorithm, AlgorithmParameters params,",
                "            Key key, String variant) {",
                "        this.algorithm = algorithm;",
                "        algParams = params;",
                "        this.key = key;",
                "        curveStr = getNamedCurveFromKey(key);",
                "        cert = null;",
                "        trustedMatch = false;",
                "        pkixDate = null;",
                "        jarTimestamp = null;",
                "        this.variant = (variant == null ? Validator.VAR_GENERIC : variant);",
                "    }",
                "",
                "",
                "    public ConstraintsParameters(X509Certificate c) {",
                "        this(c, false, null, null,",
                "                Validator.VAR_GENERIC);",
                "    }",
                " "
            ]
        },
        "chunk_120": {
            "plus_lines": [
                " ",
                "    /**",
                "     * Returns the date that should be checked against the constraints, or",
                "     * null if not set.",
                "     */",
                "    Date getDate();",
                " "
            ],
            "minus_lines": [
                " ",
                "    public ConstraintsParameters(Timestamp jarTime) {",
                "        this(null, false, null, jarTime, Validator.VAR_GENERIC);",
                "    }",
                "",
                "    public String getAlgorithm() {",
                "        return algorithm;",
                "    }",
                "",
                "    public AlgorithmParameters getAlgParams() {",
                "        return algParams;",
                "    }",
                "",
                "    public Key getKey() {",
                "        return key;",
                "    }",
                "",
                "    // Returns if the trust anchor has a match if anchor checking is enabled.",
                "    public boolean isTrustedMatch() {",
                "        return trustedMatch;",
                "    }",
                "",
                "    public X509Certificate getCertificate() {",
                "        return cert;",
                "    }",
                "",
                "    public Date getPKIXParamDate() {",
                "        return pkixDate;",
                "    }",
                "",
                "    public Timestamp getJARTimestamp() {",
                "        return jarTimestamp;",
                "    }",
                "",
                "    public String getVariant() {",
                "        return variant;",
                "    }",
                " "
            ]
        },
        "chunk_121": {
            "plus_lines": [
                " ",
                "    /**",
                "     * Returns the Validator variant.",
                "     */",
                "    String getVariant();",
                " "
            ],
            "minus_lines": [
                " ",
                "    public String[] getNamedCurve() {",
                "        return curveStr;",
                "    }",
                "",
                "    public static String[] getNamedCurveFromKey(Key key) {",
                "        if (key instanceof ECKey) {",
                "            NamedCurve nc = CurveDB.lookup(((ECKey)key).getParams());",
                "            return (nc == null ? EMPTYLIST : CurveDB.getNamesByOID(nc.getObjectId()));",
                "        } else {",
                "            return EMPTYLIST;",
                "        }",
                "    }",
                " "
            ]
        },
        "chunk_122": {
            "plus_lines": [
                " ",
                "    /**",
                "     * Returns an extended message used in exceptions. See",
                "     * DisabledAlgorithmConstraints for usage.",
                "     */",
                "    String extendedExceptionMsg();",
                " }"
            ],
            "minus_lines": [
                " ",
                "    public String toString() {",
                "        StringBuilder s = new StringBuilder();",
                "        s.append(\"Cert:       \");",
                "        if (cert != null) {",
                "            s.append(cert.toString());",
                "            s.append(\"\\nSigAlgo:    \");",
                "            s.append(cert.getSigAlgName());",
                "        } else {",
                "            s.append(\"None\");",
                "        }",
                "        s.append(\"\\nAlgParams:  \");",
                "        if (getAlgParams() != null) {",
                "            getAlgParams().toString();",
                "        } else {",
                "            s.append(\"None\");",
                "        }",
                "        s.append(\"\\nNamedCurves: \");",
                "        for (String c : getNamedCurve()) {",
                "            s.append(c + \" \");",
                "        }",
                "        s.append(\"\\nVariant:    \" + getVariant());",
                "        return s.toString();",
                "    }",
                "",
                " }"
            ]
        }
    },
    "util/DisabledAlgorithmConstraints.java": {
        "chunk_123": {
            "plus_lines": [
                " import java.io.PrintStream;",
                "import java.security.AlgorithmParameters;",
                " import java.security.CryptoPrimitive;"
            ],
            "minus_lines": []
        },
        "chunk_124": {
            "plus_lines": [],
            "minus_lines": [
                " import java.security.CryptoPrimitive;",
                "import java.security.AlgorithmParameters;",
                " import java.security.Key;"
            ]
        },
        "chunk_125": {
            "plus_lines": [
                " import java.security.cert.CertPathValidatorException.BasicReason;",
                "import java.security.interfaces.ECKey;",
                "import java.security.spec.AlgorithmParameterSpec;",
                "import java.security.spec.InvalidParameterSpecException;",
                "import java.security.spec.MGF1ParameterSpec;",
                "import java.security.spec.PSSParameterSpec;",
                " import java.text.SimpleDateFormat;"
            ],
            "minus_lines": [
                " import java.security.cert.CertPathValidatorException.BasicReason;",
                "import java.security.cert.X509Certificate;",
                " import java.text.SimpleDateFormat;"
            ]
        },
        "chunk_126": {
            "plus_lines": [
                " import java.util.ArrayList;",
                "import java.util.Arrays;",
                " import java.util.Calendar;"
            ],
            "minus_lines": []
        },
        "chunk_127": {
            "plus_lines": [
                " import java.util.Collection;",
                "import java.util.Collections;",
                " import java.util.StringTokenizer;"
            ],
            "minus_lines": []
        },
        "chunk_128": {
            "plus_lines": [
                " ",
                "    private static class CertPathHolder {",
                "        static final DisabledAlgorithmConstraints CONSTRAINTS =",
                "            new DisabledAlgorithmConstraints(PROPERTY_CERTPATH_DISABLED_ALGS);",
                "    }",
                "",
                "    private static class JarHolder {",
                "        static final DisabledAlgorithmConstraints CONSTRAINTS =",
                "            new DisabledAlgorithmConstraints(PROPERTY_JAR_DISABLED_ALGS);",
                "    }",
                "",
                "     private final List<String> disabledAlgorithms;"
            ],
            "minus_lines": []
        },
        "chunk_129": {
            "plus_lines": [
                " ",
                "    public static DisabledAlgorithmConstraints certPathConstraints() {",
                "        return CertPathHolder.CONSTRAINTS;",
                "    }",
                "",
                "    public static DisabledAlgorithmConstraints jarConstraints() {",
                "        return JarHolder.CONSTRAINTS;",
                "    }",
                "",
                "     /**"
            ],
            "minus_lines": []
        },
        "chunk_130": {
            "plus_lines": [
                "         }",
                "        algorithmConstraints = new Constraints(propertyName, disabledAlgorithms);",
                "     }"
            ],
            "minus_lines": [
                "         }",
                "        algorithmConstraints = new Constraints(disabledAlgorithms);",
                "     }"
            ]
        },
        "chunk_131": {
            "plus_lines": [
                " ",
                "    public final void permits(String algorithm, AlgorithmParameters ap,",
                "        ConstraintsParameters cp) throws CertPathValidatorException {",
                "",
                "        permits(algorithm, cp);",
                "        if (ap != null) {",
                "            permits(ap, cp);",
                "        }",
                "    }",
                "",
                "    private void permits(AlgorithmParameters ap, ConstraintsParameters cp)",
                "        throws CertPathValidatorException {",
                "",
                "        switch (ap.getAlgorithm().toUpperCase(Locale.ENGLISH)) {",
                "            case \"RSASSA-PSS\":",
                "                permitsPSSParams(ap, cp);",
                "                break;",
                "            default:",
                "                // unknown algorithm, just ignore",
                "        }",
                "     }"
            ],
            "minus_lines": [
                " ",
                "    public final void permits(ConstraintsParameters cp)",
                "            throws CertPathValidatorException {",
                "        permits(cp.getAlgorithm(), cp);",
                "     }"
            ]
        },
        "chunk_132": {
            "plus_lines": [
                " ",
                "    private void permitsPSSParams(AlgorithmParameters ap,",
                "        ConstraintsParameters cp) throws CertPathValidatorException {",
                " "
            ],
            "minus_lines": [
                " ",
                "    public final void permits(String algorithm, Key key,",
                "            AlgorithmParameters params, String variant)",
                "            throws CertPathValidatorException {",
                "        permits(algorithm, new ConstraintsParameters(algorithm, params, key,",
                "                (variant == null) ? Validator.VAR_GENERIC : variant));",
                "    }",
                " "
            ]
        },
        "chunk_133": {
            "plus_lines": [
                " ",
                "        try {",
                "            PSSParameterSpec pssParams =",
                "                ap.getParameterSpec(PSSParameterSpec.class);",
                "            String digestAlg = pssParams.getDigestAlgorithm();",
                "            permits(digestAlg, cp);",
                "            AlgorithmParameterSpec mgfParams = pssParams.getMGFParameters();",
                "            if (mgfParams instanceof MGF1ParameterSpec) {",
                "                String mgfDigestAlg =",
                "                    ((MGF1ParameterSpec)mgfParams).getDigestAlgorithm();",
                "                if (!mgfDigestAlg.equalsIgnoreCase(digestAlg)) {",
                "                    permits(mgfDigestAlg, cp);",
                "                }",
                "            }",
                "        } catch (InvalidParameterSpecException ipse) {",
                "            // ignore",
                "        }",
                "    }",
                " "
            ],
            "minus_lines": [
                " ",
                "    /*",
                "     * Check if a x509Certificate object is permitted.  Check if all",
                "     * algorithms are allowed, certificate constraints, and the",
                "     * public key against key constraints.",
                "     *",
                "     * Uses new style permit() which throws exceptions.",
                "     */",
                " "
            ]
        },
        "chunk_134": {
            "plus_lines": [
                " ",
                "        // Check if named curves in the key are disabled.",
                "        for (Key key : cp.getKeys()) {",
                "            for (String curve : getNamedCurveFromKey(key)) {",
                "                 if (!checkAlgorithm(disabledAlgorithms, curve, decomposer)) {"
            ],
            "minus_lines": [
                " ",
                "        // Check if named curves in the ConstraintParameters are disabled.",
                "        if (cp.getNamedCurve() != null) {",
                "            for (String curve : cp.getNamedCurve()) {",
                "                 if (!checkAlgorithm(disabledAlgorithms, curve, decomposer)) {"
            ]
        },
        "chunk_135": {
            "plus_lines": [
                " ",
                "    private static List<String> getNamedCurveFromKey(Key key) {",
                "        if (key instanceof ECKey) {",
                "            NamedCurve nc = CurveDB.lookup(((ECKey)key).getParams());",
                "            return (nc == null ? Collections.emptyList()",
                "                               : Arrays.asList(CurveDB.getNamesByOID(nc.getObjectId())));",
                "        } else {",
                "            return Collections.emptyList();",
                "         }"
            ],
            "minus_lines": [
                " ",
                "    // Check if a string is contained inside the property",
                "    public boolean checkProperty(String param) {",
                "        param = param.toLowerCase(Locale.ENGLISH);",
                "        for (String block : disabledAlgorithms) {",
                "            if (block.toLowerCase(Locale.ENGLISH).indexOf(param) >= 0) {",
                "                return true;",
                "            }",
                "         }"
            ]
        },
        "chunk_136": {
            "plus_lines": [],
            "minus_lines": [
                "         }",
                "        return false;",
                "     }"
            ]
        },
        "chunk_137": {
            "plus_lines": [
                " ",
                "        // If this is an elliptic curve, check if it is disabled",
                "        for (String curve : getNamedCurveFromKey(key)) {",
                "             if (!permits(primitives, curve, null)) {"
            ],
            "minus_lines": [
                " ",
                "        // If this is an elliptic curve, check disabled the named curve.",
                "        for (String curve : ConstraintsParameters.getNamedCurveFromKey(key)) {",
                "             if (!permits(primitives, curve, null)) {"
            ]
        },
        "chunk_138": {
            "plus_lines": [
                " ",
                "        public Constraints(String propertyName, List<String> constraintArray) {",
                "             for (String constraintEntry : constraintArray) {"
            ],
            "minus_lines": [
                " ",
                "        public Constraints(List<String> constraintArray) {",
                "             for (String constraintEntry : constraintArray) {"
            ]
        },
        "chunk_139": {
            "plus_lines": [
                " ",
                "        // Get applicable constraints based off the algorithm",
                "         private List<Constraint> getConstraints(String algorithm) {"
            ],
            "minus_lines": [
                " ",
                "        // Get applicable constraints based off the signature algorithm",
                "         private List<Constraint> getConstraints(String algorithm) {"
            ]
        },
        "chunk_140": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "        // Check if constraints permit this cert.",
                "         public void permits(String algorithm, ConstraintsParameters cp)"
            ]
        },
        "chunk_141": {
            "plus_lines": [],
            "minus_lines": [
                "                 throws CertPathValidatorException {",
                "            X509Certificate cert = cp.getCertificate();",
                " "
            ]
        },
        "chunk_142": {
            "plus_lines": [
                "             if (debug != null) {",
                "                debug.println(\"Constraints.permits(): \" + algorithm + \", \"",
                "                              + cp.toString());",
                "             }"
            ],
            "minus_lines": [
                "             if (debug != null) {",
                "                debug.println(\"Constraints.permits(): \" + cp.toString());",
                "             }"
            ]
        },
        "chunk_143": {
            "plus_lines": [
                " ",
                "            for (Key key : cp.getKeys()) {",
                "                algorithms.add(key.getAlgorithm());",
                "             }"
            ],
            "minus_lines": [
                " ",
                "            // Attempt to add the public key algorithm if cert provided",
                "            if (cert != null) {",
                "                algorithms.add(cert.getPublicKey().getAlgorithm());",
                "             }"
            ]
        },
        "chunk_144": {
            "plus_lines": [
                "             }",
                "",
                "             // Check all applicable constraints"
            ],
            "minus_lines": [
                "             }",
                "            if (cp.getKey() != null) {",
                "                algorithms.add(cp.getKey().getAlgorithm());",
                "            }",
                "             // Check all applicable constraints"
            ]
        },
        "chunk_145": {
            "plus_lines": [
                "          *",
                "         * @param cp ConstraintsParameter containing certificate info",
                "          * @throws CertPathValidatorException if constraint disallows."
            ],
            "minus_lines": [
                "          *",
                "         * @param cp CertConstraintParameter containing certificate info",
                "          * @throws CertPathValidatorException if constraint disallows."
            ]
        },
        "chunk_146": {
            "plus_lines": [],
            "minus_lines": [
                "         }",
                "",
                "        String extendedMsg(ConstraintsParameters cp) {",
                "            return (cp.getCertificate() == null ? \".\" :",
                "                    \" used with certificate: \" +",
                "                            cp.getCertificate().getSubjectX500Principal() +",
                "                    (cp.getVariant() != Validator.VAR_GENERIC ?",
                "                            \".  Usage was \" + cp.getVariant() : \".\"));",
                "        }",
                "     }"
            ]
        },
        "chunk_147": {
            "plus_lines": [
                " ",
                "            // Check if any certs chain back to at least one trust anchor in",
                "            // cacerts",
                "            if (cp.anchorIsJdkCA()) {",
                "                 if (next(cp)) {"
            ],
            "minus_lines": [
                " ",
                "            // Check chain has a trust anchor in cacerts",
                "            if (cp.isTrustedMatch()) {",
                "                 if (next(cp)) {"
            ]
        },
        "chunk_148": {
            "plus_lines": [
                "                         \"Algorithm constraints check failed on certificate \" +",
                "                        \"anchor limits. \" + algorithm + cp.extendedExceptionMsg(),",
                "                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);"
            ],
            "minus_lines": [
                "                         \"Algorithm constraints check failed on certificate \" +",
                "                        \"anchor limits. \" + algorithm + extendedMsg(cp),",
                "                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);"
            ]
        },
        "chunk_149": {
            "plus_lines": [
                " ",
                "            if (cp.getDate() != null) {",
                "                currentDate = cp.getDate();",
                "             } else {"
            ],
            "minus_lines": [
                " ",
                "            if (cp.getJARTimestamp() != null) {",
                "                currentDate = cp.getJARTimestamp().getTimestamp();",
                "                errmsg = \"JAR Timestamp date: \";",
                "            } else if (cp.getPKIXParamDate() != null) {",
                "                currentDate = cp.getPKIXParamDate();",
                "                errmsg = \"PKIXParameter date: \";",
                "             } else {"
            ]
        },
        "chunk_150": {
            "plus_lines": [],
            "minus_lines": [
                "                 currentDate = new Date();",
                "                errmsg = \"Current date: \";",
                "             }"
            ]
        },
        "chunk_151": {
            "plus_lines": [
                "                         \" used with Constraint date: \" +",
                "                        dateFormat.format(denyAfterDate) + \"; params date: \" +",
                "                        dateFormat.format(currentDate) + cp.extendedExceptionMsg(),",
                "                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);"
            ],
            "minus_lines": [
                "                         \" used with Constraint date: \" +",
                "                        dateFormat.format(denyAfterDate) + \"; \" + errmsg +",
                "                        dateFormat.format(currentDate) + extendedMsg(cp),",
                "                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);"
            ]
        },
        "chunk_152": {
            "plus_lines": [
                "                 throws CertPathValidatorException {",
                "            String variant = cp.getVariant();",
                "             for (String usage : usages) {"
            ],
            "minus_lines": []
        },
        "chunk_153": {
            "plus_lines": [
                " ",
                "                boolean match = false;",
                "                switch (usage.toLowerCase()) {",
                "                    case \"tlsserver\":",
                "                        match = variant.equals(Validator.VAR_TLS_SERVER);",
                "                        break;",
                "                    case \"tlsclient\":",
                "                        match = variant.equals(Validator.VAR_TLS_CLIENT);",
                "                        break;",
                "                    case \"signedjar\":",
                "                        match =",
                "                            variant.equals(Validator.VAR_PLUGIN_CODE_SIGNING) ||",
                "                            variant.equals(Validator.VAR_CODE_SIGNING) ||",
                "                            variant.equals(Validator.VAR_TSA_SERVER);",
                "                        break;",
                "                 }"
            ],
            "minus_lines": [
                " ",
                "                String v = null;",
                "                if (usage.compareToIgnoreCase(\"TLSServer\") == 0) {",
                "                    v = Validator.VAR_TLS_SERVER;",
                "                } else if (usage.compareToIgnoreCase(\"TLSClient\") == 0) {",
                "                    v = Validator.VAR_TLS_CLIENT;",
                "                } else if (usage.compareToIgnoreCase(\"SignedJAR\") == 0) {",
                "                    v = Validator.VAR_PLUGIN_CODE_SIGNING;",
                "                 }"
            ]
        },
        "chunk_154": {
            "plus_lines": [
                "                 if (debug != null) {",
                "                    debug.println(\"Checking if usage constraint \\\"\" + usage +",
                "                             \"\\\" matches \\\"\" + cp.getVariant() + \"\\\"\");"
            ],
            "minus_lines": [
                "                 if (debug != null) {",
                "                    debug.println(\"Checking if usage constraint \\\"\" + v +",
                "                             \"\\\" matches \\\"\" + cp.getVariant() + \"\\\"\");"
            ]
        },
        "chunk_155": {
            "plus_lines": [
                "                 }",
                "                if (match) {",
                "                     if (next(cp)) {"
            ],
            "minus_lines": [
                "                 }",
                "                if (cp.getVariant().compareTo(v) == 0) {",
                "                     if (next(cp)) {"
            ]
        },
        "chunk_156": {
            "plus_lines": [
                "                             usage + \" check failed: \" + algorithm +",
                "                            cp.extendedExceptionMsg(),",
                "                             null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);"
            ],
            "minus_lines": [
                "                             usage + \" check failed: \" + algorithm +",
                "                            extendedMsg(cp),",
                "                             null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);"
            ]
        },
        "chunk_157": {
            "plus_lines": [
                "         /*",
                "         * For each key, check if each constraint fails and check if there is",
                "         * a linked constraint. Any permitted constraint will exit the linked",
                "         * list to allow the operation.",
                "          */"
            ],
            "minus_lines": [
                "         /*",
                "         * If we are passed a certificate, extract the public key and use it.",
                "         *",
                "         * Check if each constraint fails and check if there is a linked",
                "         * constraint  Any permitted constraint will exit the linked list",
                "         * to allow the operation.",
                "          */"
            ]
        },
        "chunk_158": {
            "plus_lines": [
                "                 throws CertPathValidatorException {",
                "            for (Key key : cp.getKeys()) {",
                "                if (!permitsImpl(key)) {",
                "                    if (nextConstraint != null) {",
                "                        nextConstraint.permits(cp);",
                "                        continue;",
                "                    }",
                "                    throw new CertPathValidatorException(",
                "                        \"Algorithm constraints check failed on keysize limits: \" +",
                "                        algorithm + \" \" + KeyUtil.getKeySize(key) + \" bit key\" +",
                "                        cp.extendedExceptionMsg(),",
                "                        null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);",
                "                 }"
            ],
            "minus_lines": [
                "                 throws CertPathValidatorException {",
                "            Key key = null;",
                "            if (cp.getKey() != null) {",
                "                key = cp.getKey();",
                "            } else if (cp.getCertificate() != null) {",
                "                key = cp.getCertificate().getPublicKey();",
                "            }",
                "            if (key != null && !permitsImpl(key)) {",
                "                if (nextConstraint != null) {",
                "                    nextConstraint.permits(cp);",
                "                    return;",
                "                 }"
            ]
        },
        "chunk_159": {
            "plus_lines": [],
            "minus_lines": [
                "                 }",
                "                throw new CertPathValidatorException(",
                "                        \"Algorithm constraints check failed on keysize limits. \" +",
                "                        algorithm + \" \" + KeyUtil.getKeySize(key) + \"bit key\" +",
                "                        extendedMsg(cp),",
                "                        null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);",
                "             }"
            ]
        },
        "chunk_160": {
            "plus_lines": [
                "                     \"Algorithm constraints check failed on disabled \" +",
                "                            \"algorithm: \" + algorithm + cp.extendedExceptionMsg(),",
                "                     null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);"
            ],
            "minus_lines": [
                "                     \"Algorithm constraints check failed on disabled \" +",
                "                            \"algorithm: \" + algorithm + extendedMsg(cp),",
                "                     null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);"
            ]
        }
    },
    "util/JarConstraintsParameters.java": {
        "chunk_161": {
            "plus_lines": [
                "@@ -0,0 +1,188 @@",
                "/*",
                " * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.",
                " * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.",
                " *",
                " * This code is free software; you can redistribute it and/or modify it",
                " * under the terms of the GNU General Public License version 2 only, as",
                " * published by the Free Software Foundation.  Oracle designates this",
                " * particular file as subject to the \"Classpath\" exception as provided",
                " * by Oracle in the LICENSE file that accompanied this code.",
                " *",
                " * This code is distributed in the hope that it will be useful, but WITHOUT",
                " * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or",
                " * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License",
                " * version 2 for more details (a copy is included in the LICENSE file that",
                " * accompanied this code).",
                " *",
                " * You should have received a copy of the GNU General Public License version",
                " * 2 along with this work; if not, write to the Free Software Foundation,",
                " * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.",
                " *",
                " * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA",
                " * or visit www.oracle.com if you need additional information or have any",
                " * questions.",
                " */",
                "",
                "package sun.security.util;",
                "",
                "import java.security.CodeSigner;",
                "import java.security.Key;",
                "import java.security.Timestamp;",
                "import java.security.cert.CertPath;",
                "import java.security.cert.X509Certificate;",
                "import java.util.Date;",
                "import java.util.HashSet;",
                "import java.util.List;",
                "import java.util.Set;",
                "import sun.security.util.AnchorCertificates;",
                "import sun.security.util.ConstraintsParameters;",
                "import sun.security.validator.Validator;",
                "",
                "/**",
                " * This class contains parameters for checking signed JARs against",
                " * constraints specified in the jdk.jar.disabledAlgorithms security",
                " * property.",
                " */",
                "public class JarConstraintsParameters implements ConstraintsParameters {",
                "",
                "    // true if chain is anchored by a JDK root CA",
                "    private boolean anchorIsJdkCA;",
                "    private boolean anchorIsJdkCASet;",
                "    // The timestamp of the signed JAR file, if timestamped",
                "    private Date timestamp;",
                "    // The keys of the signers",
                "    private final Set<Key> keys;",
                "    // The certs in the signers' chains that are issued by the trust anchor",
                "    private final Set<X509Certificate> certsIssuedByAnchor;",
                "    // The extended exception message",
                "    private String message;",
                "",
                "    /**",
                "     * Create a JarConstraintsParameters.",
                "     *",
                "     * @param signers the CodeSigners that signed the JAR",
                "     */",
                "    public JarConstraintsParameters(CodeSigner[] signers) {",
                "        this.keys = new HashSet<>();",
                "        this.certsIssuedByAnchor = new HashSet<>();",
                "        Date latestTimestamp = null;",
                "        boolean skipTimestamp = false;",
                "",
                "        // Iterate over the signers and extract the keys, the latest",
                "        // timestamp, and the last certificate of each chain which can be",
                "        // used for checking if the signer's certificate chains back to a",
                "        // JDK root CA",
                "        for (CodeSigner signer : signers) {",
                "            init(signer.getSignerCertPath());",
                "            Timestamp timestamp = signer.getTimestamp();",
                "            if (timestamp == null) {",
                "                // this means one of the signers doesn't have a timestamp",
                "                // and the JAR should be treated as if it isn't timestamped",
                "                latestTimestamp = null;",
                "                skipTimestamp = true;",
                "            } else {",
                "                // add the key and last cert of TSA too",
                "                init(timestamp.getSignerCertPath());",
                "                if (!skipTimestamp) {",
                "                    Date timestampDate = timestamp.getTimestamp();",
                "                    if (latestTimestamp == null) {",
                "                        latestTimestamp = timestampDate;",
                "                    } else {",
                "                        if (latestTimestamp.before(timestampDate)) {",
                "                            latestTimestamp = timestampDate;",
                "                        }",
                "                    }",
                "                }",
                "            }",
                "        }",
                "        this.timestamp = latestTimestamp;",
                "    }",
                "",
                "    // extract last certificate and key from chain",
                "    private void init(CertPath cp) {",
                "        @SuppressWarnings(\"unchecked\")",
                "        List<X509Certificate> chain =",
                "            (List<X509Certificate>)cp.getCertificates();",
                "        if (!chain.isEmpty()) {",
                "            this.certsIssuedByAnchor.add(chain.get(chain.size() - 1));",
                "            this.keys.add(chain.get(0).getPublicKey());",
                "        }",
                "    }",
                "",
                "    @Override",
                "    public String getVariant() {",
                "        return Validator.VAR_GENERIC;",
                "    }",
                "",
                "    /**",
                "     * Since loading the cacerts keystore can be an expensive operation,",
                "     * this is only performed if this method is called during a \"jdkCA\"",
                "     * constraints check of a disabled algorithm, and the result is cached.",
                "     *",
                "     * @return true if at least one of the certificates are issued by a",
                "     *              JDK root CA",
                "     */",
                "    @Override",
                "    public boolean anchorIsJdkCA() {",
                "        if (anchorIsJdkCASet) {",
                "            return anchorIsJdkCA;",
                "        }",
                "        for (X509Certificate cert : certsIssuedByAnchor) {",
                "            if (AnchorCertificates.issuerOf(cert)) {",
                "                anchorIsJdkCA = true;",
                "                break;",
                "            }",
                "        }",
                "        anchorIsJdkCASet = true;",
                "        return anchorIsJdkCA;",
                "    }",
                "",
                "    @Override",
                "    public Date getDate() {",
                "        return timestamp;",
                "    }",
                "",
                "    @Override",
                "    public Set<Key> getKeys() {",
                "        return keys;",
                "    }",
                "",
                "    /**",
                "     * Sets the extended error message. Note: this should be used",
                "     * carefully as it is specific to the attribute/entry/file being checked.",
                "     *",
                "     * @param file the name of the signature related file being verified",
                "     * @param target the attribute containing the algorithm that is being",
                "     *        checked",
                "     */",
                "    public void setExtendedExceptionMsg(String file, String target) {",
                "        message = \" used\" + (target != null ? \" with \" + target : \"\") +",
                "                  \" in \" + file + \" file.\";",
                "    }",
                "",
                "    @Override",
                "    public String extendedExceptionMsg() {",
                "        return message;",
                "    }",
                "",
                "    @Override",
                "    public String toString() {",
                "        StringBuilder sb = new StringBuilder(\"[\\n\");",
                "        sb.append(\"\\n  Variant: \").append(getVariant());",
                "        sb.append(\"\\n  Certs Issued by Anchor:\");",
                "        for (X509Certificate cert : certsIssuedByAnchor) {",
                "            sb.append(\"\\n    Cert Issuer: \")",
                "              .append(cert.getIssuerX500Principal());",
                "            sb.append(\"\\n    Cert Subject: \")",
                "              .append(cert.getSubjectX500Principal());",
                "        }",
                "        for (Key key : keys) {",
                "            sb.append(\"\\n  Key: \").append(key.getAlgorithm());",
                "        }",
                "        if (timestamp != null) {",
                "            sb.append(\"\\n  Timestamp: \").append(timestamp);",
                "        }",
                "        sb.append(\"\\n]\");",
                "        return sb.toString();",
                "    }",
                "}"
            ],
            "minus_lines": []
        }
    },
    "util/ManifestEntryVerifier.java": {
        "chunk_162": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_163": {
            "plus_lines": [],
            "minus_lines": [
                " import java.io.*;",
                "import java.security.CodeSigner;",
                " import java.util.*;"
            ]
        },
        "chunk_164": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "import java.util.Base64;",
                "",
                " import sun.security.jca.Providers;"
            ]
        },
        "chunk_165": {
            "plus_lines": [
                " import sun.security.jca.Providers;",
                "import sun.security.util.DisabledAlgorithmConstraints;",
                "import sun.security.util.JarConstraintsParameters;",
                " "
            ],
            "minus_lines": []
        },
        "chunk_166": {
            "plus_lines": [
                " ",
                "        if (signers != null) {",
                "             return signers;"
            ],
            "minus_lines": [
                " ",
                "        if (signers != null)",
                "             return signers;"
            ]
        },
        "chunk_167": {
            "plus_lines": [
                "             return signers;",
                "        }",
                "",
                "        JarConstraintsParameters params =",
                "            getParams(verifiedSigners, sigFileSigners);",
                " "
            ],
            "minus_lines": []
        },
        "chunk_168": {
            "plus_lines": [
                " ",
                "            MessageDigest digest = digests.get(i);",
                "            if (params != null) {",
                "                try {",
                "                    params.setExtendedExceptionMsg(JarFile.MANIFEST_NAME,",
                "                        name + \" entry\");",
                "                    DisabledAlgorithmConstraints.jarConstraints()",
                "                           .permits(digest.getAlgorithm(), params);",
                "                } catch (GeneralSecurityException e) {",
                "                    if (debug != null) {",
                "                        debug.println(\"Digest algorithm is restricted: \" + e);",
                "                    }",
                "                    return null;",
                "                }",
                "            }",
                "             byte [] manHash = manifestHashes.get(i);"
            ],
            "minus_lines": [
                " ",
                "            MessageDigest digest  = digests.get(i);",
                "             byte [] manHash = manifestHashes.get(i);"
            ]
        },
        "chunk_169": {
            "plus_lines": [
                " ",
                "    /**",
                "     * Get constraints parameters for JAR. The constraints should be",
                "     * checked against all code signers. Returns the parameters,",
                "     * or null if the signers for this entry have already been checked.",
                "     */",
                "    private JarConstraintsParameters getParams(",
                "            Map<String, CodeSigner[]> verifiedSigners,",
                "            Map<String, CodeSigner[]> sigFileSigners) {",
                "",
                "        // verifiedSigners is usually preloaded with the Manifest's signers.",
                "        // If verifiedSigners contains the Manifest, then it will have all of",
                "        // the signers of the JAR. But if it doesn't then we need to fallback",
                "        // and check verifiedSigners to see if the signers of this entry have",
                "        // been checked already.",
                "        if (verifiedSigners.containsKey(JarFile.MANIFEST_NAME)) {",
                "            if (verifiedSigners.size() > 1) {",
                "                // this means we already checked it previously",
                "                return null;",
                "            } else {",
                "                return new JarConstraintsParameters(",
                "                    verifiedSigners.get(JarFile.MANIFEST_NAME));",
                "            }",
                "        } else {",
                "            CodeSigner[] signers = sigFileSigners.get(name);",
                "            if (verifiedSigners.containsValue(signers)) {",
                "                return null;",
                "            } else {",
                "                return new JarConstraintsParameters(signers);",
                "            }",
                "        }",
                "    }",
                "",
                "     // for the toHex function"
            ],
            "minus_lines": []
        }
    },
    "util/SignatureFileVerifier.java": {
        "chunk_170": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_171": {
            "plus_lines": [],
            "minus_lines": [
                " import java.security.SignatureException;",
                "import java.security.Timestamp;",
                " import java.security.cert.CertPath;"
            ]
        },
        "chunk_172": {
            "plus_lines": [
                " import java.util.Map;",
                "import java.util.Set;",
                " import java.util.jar.Attributes;"
            ],
            "minus_lines": []
        },
        "chunk_173": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "    private static final DisabledAlgorithmConstraints JAR_DISABLED_CHECK =",
                "            new DisabledAlgorithmConstraints(",
                "                    DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);",
                "",
                "     private ArrayList<CodeSigner[]> signerCache;"
            ]
        },
        "chunk_174": {
            "plus_lines": [
                " ",
                "    /** Algorithms that have been previously checked against disabled",
                "     *  constraints.",
                "     */",
                "    private Map<String, Boolean> permittedAlgs = new HashMap<>();",
                " "
            ],
            "minus_lines": [
                " ",
                "    /** Algorithms that have been checked if they are weak. */",
                "    private Map<String, Boolean> permittedAlgs= new HashMap<>();",
                " "
            ]
        },
        "chunk_175": {
            "plus_lines": [
                " ",
                "    /** ConstraintsParameters for checking disabled algorithms */",
                "    private JarConstraintsParameters params;",
                " "
            ],
            "minus_lines": [
                " ",
                "    /** TSA timestamp of signed jar.  The newest timestamp is used.  If there",
                "     *  was no TSA timestamp used when signed, current time is used (\"null\").",
                "     */",
                "    private Timestamp timestamp = null;",
                " "
            ]
        },
        "chunk_176": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "",
                "         CodeSigner[] newSigners = getSigners(infos, block);"
            ]
        },
        "chunk_177": {
            "plus_lines": [
                "         // make sure we have something to do all this work for...",
                "        if (newSigners == null) {",
                "             return;"
            ],
            "minus_lines": [
                "         // make sure we have something to do all this work for...",
                "        if (newSigners == null)",
                "             return;"
            ]
        },
        "chunk_178": {
            "plus_lines": [
                "             return;",
                "        }",
                " "
            ],
            "minus_lines": []
        },
        "chunk_179": {
            "plus_lines": [
                " ",
                "        // check if any of the algorithms used to verify the SignerInfos",
                "        // are disabled",
                "        params = new JarConstraintsParameters(newSigners);",
                "        Set<String> notDisabledAlgorithms =",
                "            SignerInfo.verifyAlgorithms(infos, params, name + \" PKCS7\");",
                "",
                "        // add the SignerInfo algorithms that are ok to the permittedAlgs map",
                "        // so they are not checked again",
                "        for (String algorithm : notDisabledAlgorithms) {",
                "            permittedAlgs.put(algorithm, Boolean.TRUE);",
                "         }"
            ],
            "minus_lines": [
                " ",
                "        /*",
                "         * Look for the latest timestamp in the signature block.  If an entry",
                "         * has no timestamp, use current time (aka null).",
                "         */",
                "        for (CodeSigner s: newSigners) {",
                "            if (debug != null) {",
                "                debug.println(\"Gathering timestamp for:  \" + s.toString());",
                "            }",
                "            if (s.getTimestamp() == null) {",
                "                timestamp = null;",
                "                break;",
                "            } else if (timestamp == null) {",
                "                timestamp = s.getTimestamp();",
                "            } else {",
                "                if (timestamp.getTimestamp().before(",
                "                        s.getTimestamp().getTimestamp())) {",
                "                    timestamp = s.getTimestamp();",
                "                }",
                "            }",
                "         }"
            ]
        },
        "chunk_180": {
            "plus_lines": [
                "      */",
                "    private boolean permittedCheck(String key, String algorithm) {",
                "         Boolean permitted = permittedAlgs.get(algorithm);"
            ],
            "minus_lines": [
                "      */",
                "    boolean permittedCheck(String key, String algorithm) {",
                "         Boolean permitted = permittedAlgs.get(algorithm);"
            ]
        },
        "chunk_181": {
            "plus_lines": [
                "             try {",
                "                params.setExtendedExceptionMsg(name + \".SF\", key + \" attribute\");",
                "                DisabledAlgorithmConstraints",
                "                    .jarConstraints().permits(algorithm, params);",
                "            } catch (GeneralSecurityException e) {",
                "                 permittedAlgs.put(algorithm, Boolean.FALSE);"
            ],
            "minus_lines": [
                "             try {",
                "                JAR_DISABLED_CHECK.permits(algorithm,",
                "                        new ConstraintsParameters(timestamp));",
                "            } catch(GeneralSecurityException e) {",
                "                 permittedAlgs.put(algorithm, Boolean.FALSE);"
            ]
        }
    },
    "validator/PKIXValidator.java": {
        "chunk_182": {
            "plus_lines": [
                "             pkixParameters.addCertPathChecker(",
                "                    new AlgorithmChecker(constraints, variant));",
                "         }"
            ],
            "minus_lines": [
                "             pkixParameters.addCertPathChecker(",
                "                    new AlgorithmChecker(constraints, null, variant));",
                "         }"
            ]
        }
    },
    "validator/SimpleValidator.java": {
        "chunk_183": {
            "plus_lines": [
                "             appAlgChecker = new AlgorithmChecker(anchor, constraints, null,",
                "                    variant);",
                "         }"
            ],
            "minus_lines": [
                "             appAlgChecker = new AlgorithmChecker(anchor, constraints, null,",
                "                    null, variant);",
                "         }"
            ]
        }
    },
    "x509/AlgorithmId.java": {
        "chunk_184": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 1996, 2021, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_185": {
            "plus_lines": [
                " ",
                "    private transient byte[] encodedParams;",
                " "
            ],
            "minus_lines": []
        },
        "chunk_186": {
            "plus_lines": [
                "         constructedFromDer = false;",
                "        if (algParams != null) {",
                "            try {",
                "                encodedParams = algParams.getEncoded();",
                "            } catch (IOException ioe) {",
                "                // It should be safe to ignore this.",
                "                // This exception can occur if AlgorithmParameters was not",
                "                // initialized (which should not occur), or if it was",
                "                // initialized with bogus parameters, which should have",
                "                // been detected when init was called.",
                "                assert false;",
                "            }",
                "        }",
                "     }"
            ],
            "minus_lines": []
        },
        "chunk_187": {
            "plus_lines": [
                "         if (this.params != null) {",
                "            encodedParams = params.toByteArray();",
                "             decodeParams();"
            ],
            "minus_lines": []
        },
        "chunk_188": {
            "plus_lines": [
                "         // Decode (parse) the parameters",
                "        algParams.init(encodedParams.clone());",
                "     }"
            ],
            "minus_lines": [
                "         // Decode (parse) the parameters",
                "        algParams.init(params.toByteArray());",
                "     }"
            ]
        },
        "chunk_189": {
            "plus_lines": [
                "      */",
                "    @Override",
                "     public void derEncode (OutputStream out) throws IOException {"
            ],
            "minus_lines": []
        },
        "chunk_190": {
            "plus_lines": [
                "         if (constructedFromDer == false) {",
                "            if (encodedParams != null) {",
                "                params = new DerValue(encodedParams);",
                "             } else {"
            ],
            "minus_lines": [
                "         if (constructedFromDer == false) {",
                "            if (algParams != null) {",
                "                params = new DerValue(algParams.getEncoded());",
                "             } else {"
            ]
        },
        "chunk_191": {
            "plus_lines": [
                "                 AlgorithmId paramsId =",
                "                        AlgorithmId.parse(new DerValue(encodedParams));",
                "                 String paramsName = paramsId.getName();"
            ],
            "minus_lines": [
                "                 AlgorithmId paramsId =",
                "                        AlgorithmId.parse(new DerValue(params.toByteArray()));",
                "                 String paramsName = paramsId.getName();"
            ]
        },
        "chunk_192": {
            "plus_lines": [
                "      *",
                "     * Note that this* method should always return a new array as it is called",
                "     * directly by the JDK implementation of X509Certificate.getSigAlgParams()",
                "     * and X509CRL.getSigAlgParams().",
                "     *",
                "      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method"
            ],
            "minus_lines": []
        },
        "chunk_193": {
            "plus_lines": [
                "     public byte[] getEncodedParams() throws IOException {",
                "        return (encodedParams == null || algid.equals(specifiedWithECDSA_oid))",
                "                 ? null"
            ],
            "minus_lines": [
                "     public byte[] getEncodedParams() throws IOException {",
                "        return (params == null || algid.equals(specifiedWithECDSA_oid))",
                "                 ? null"
            ]
        },
        "chunk_194": {
            "plus_lines": [
                "                 ? null",
                "                : encodedParams.clone();",
                "     }"
            ],
            "minus_lines": [
                "                 ? null",
                "                : params.toByteArray();",
                "     }"
            ]
        },
        "chunk_195": {
            "plus_lines": [
                "     public boolean equals(AlgorithmId other) {",
                "        return algid.equals((Object)other.algid) &&",
                "            Arrays.equals(encodedParams, other.encodedParams);",
                "     }"
            ],
            "minus_lines": [
                "     public boolean equals(AlgorithmId other) {",
                "        boolean paramsEqual =",
                "          (params == null ? other.params == null : params.equals(other.params));",
                "        return (algid.equals((Object)other.algid) && paramsEqual);",
                "     }"
            ]
        },
        "chunk_196": {
            "plus_lines": [
                "      */",
                "    @Override",
                "     public boolean equals(Object other) {"
            ],
            "minus_lines": []
        },
        "chunk_197": {
            "plus_lines": [
                "      */",
                "    @Override",
                "     public int hashCode() {"
            ],
            "minus_lines": []
        },
        "chunk_198": {
            "plus_lines": [
                "     public int hashCode() {",
                "        int hashCode = algid.hashCode();",
                "        hashCode = 31 * hashCode + Arrays.hashCode(encodedParams);",
                "        return hashCode;",
                "     }"
            ],
            "minus_lines": [
                "     public int hashCode() {",
                "        StringBuilder sbuf = new StringBuilder();",
                "        sbuf.append(algid.toString());",
                "        sbuf.append(paramsToString());",
                "        return sbuf.toString().hashCode();",
                "     }"
            ]
        },
        "chunk_199": {
            "plus_lines": [
                "     protected String paramsToString() {",
                "        if (encodedParams == null) {",
                "             return \"\";"
            ],
            "minus_lines": [
                "     protected String paramsToString() {",
                "        if (params == null) {",
                "             return \"\";"
            ]
        },
        "chunk_200": {
            "plus_lines": [
                "         } else if (algParams != null) {",
                "            return \", \" + algParams.toString();",
                "         } else {"
            ],
            "minus_lines": [
                "         } else if (algParams != null) {",
                "            return algParams.toString();",
                "         } else {"
            ]
        },
        "chunk_201": {
            "plus_lines": [
                "      */",
                "    @Override",
                "     public String toString() {"
            ],
            "minus_lines": []
        }
    },
    "X509Certificate/GetSigAlgParams.java": {
        "chunk_202": {
            "plus_lines": [
                "@@ -0,0 +1,46 @@",
                "/*",
                " * Copyright (c) 2021, Oracle and/or its affiliates. All rights reserved.",
                " * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.",
                " *",
                " * This code is free software; you can redistribute it and/or modify it",
                " * under the terms of the GNU General Public License version 2 only, as",
                " * published by the Free Software Foundation.",
                " *",
                " * This code is distributed in the hope that it will be useful, but WITHOUT",
                " * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or",
                " * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License",
                " * version 2 for more details (a copy is included in the LICENSE file that",
                " * accompanied this code).",
                " *",
                " * You should have received a copy of the GNU General Public License version",
                " * 2 along with this work; if not, write to the Free Software Foundation,",
                " * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.",
                " *",
                " * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA",
                " * or visit www.oracle.com if you need additional information or have any",
                " * questions.",
                " */",
                "",
                "/*",
                " * @test",
                " * @bug 8259428",
                " * @summary Verify X509Certificate.getSigAlgParams() returns new array each",
                " *          time it is called",
                " */",
                "",
                "import java.security.cert.X509Certificate;",
                "import sun.security.tools.keytool.CertAndKeyGen;",
                "import sun.security.x509.X500Name;",
                "",
                "public class GetSigAlgParams {",
                "",
                "    public static void main(String[] args) throws Exception {",
                "",
                "        CertAndKeyGen cakg = new CertAndKeyGen(\"RSASSA-PSS\", \"RSASSA-PSS\");",
                "        cakg.generate(1024);",
                "        X509Certificate c = cakg.getSelfCertificate(new X500Name(\"CN=Me\"), 100);",
                "        if (c.getSigAlgParams() == c.getSigAlgParams()) {",
                "            throw new Exception(\"Encoded params are the same byte array\");",
                "        }",
                "    }",
                "}"
            ],
            "minus_lines": []
        }
    },
    "pkcs8/PKCS8Test.java": {
        "chunk_203": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 2015, 2021, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_204": {
            "plus_lines": [
                "     static final String FORMAT = \"PKCS#8\";",
                "    static final String EXPECTED_ALG_ID_CHRS = \"DSA, \\n\\tp:     02\\n\\tq:     03\\n\"",
                "             + \"\\tg:     04\\n\";"
            ],
            "minus_lines": [
                "     static final String FORMAT = \"PKCS#8\";",
                "    static final String EXPECTED_ALG_ID_CHRS = \"DSA\\n\\tp:     02\\n\\tq:     03\\n\"",
                "             + \"\\tg:     04\\n\";"
            ]
        }
    },
    "jarsigner/TimestampCheck.java": {
        "chunk_205": {
            "plus_lines": [
                "                         .shouldHaveExitValue(68)",
                "                        .shouldContain(\"TSA certificate chain is invalid\")",
                "                         .shouldMatch(\"MD5.*-digestalg.*is disabled\")"
            ],
            "minus_lines": [
                "                         .shouldHaveExitValue(68)",
                "                        .shouldContain(\"The timestamp is invalid. Without a valid timestamp\")",
                "                         .shouldMatch(\"MD5.*-digestalg.*is disabled\")"
            ]
        },
        "chunk_206": {
            "plus_lines": [],
            "minus_lines": [
                "                         .shouldHaveExitValue(64)",
                "                        .shouldContain(\"The timestamp is invalid. Without a valid timestamp\")",
                "                         .shouldContain(\"TSA certificate chain is invalid\");"
            ]
        },
        "chunk_207": {
            "plus_lines": [
                "                 .shouldHaveExitValue(16)",
                "                .shouldMatch(\"SignatureException:.*keysize\");",
                "     }"
            ],
            "minus_lines": [
                "                 .shouldHaveExitValue(16)",
                "                .shouldMatch(\"SignatureException:.*disabled\");",
                "     }"
            ]
        }
    },
    "AlgorithmId/AlgorithmIdEqualsHashCode.java": {
        "chunk_208": {
            "plus_lines": [
                " /*",
                " * Copyright (c) 1999, 2021, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ],
            "minus_lines": [
                " /*",
                " * Copyright (c) 1999, 2005, Oracle and/or its affiliates. All rights reserved.",
                "  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER."
            ]
        },
        "chunk_209": {
            "plus_lines": [
                "  * @author Gary Ellison",
                " * @bug 4170635 8258247",
                "  * @summary Verify equals()/hashCode() contract honored"
            ],
            "minus_lines": [
                "  * @author Gary Ellison",
                " * @bug 4170635",
                "  * @summary Verify equals()/hashCode() contract honored"
            ]
        },
        "chunk_210": {
            "plus_lines": [
                " import java.io.*;",
                "import java.security.AlgorithmParameters;",
                "import java.security.spec.MGF1ParameterSpec;",
                "import java.security.spec.PSSParameterSpec;",
                " "
            ],
            "minus_lines": []
        },
        "chunk_211": {
            "plus_lines": [
                " ",
                "import sun.security.util.DerValue;",
                " import sun.security.x509.*;"
            ],
            "minus_lines": []
        },
        "chunk_212": {
            "plus_lines": [],
            "minus_lines": [
                " ",
                "",
                "         // supposedly transitivity is broken"
            ]
        },
        "chunk_213": {
            "plus_lines": [
                " ",
                "        // check that AlgorithmIds with same name but different params",
                "        // are not equal",
                "        AlgorithmParameters algParams1 =",
                "            AlgorithmParameters.getInstance(\"RSASSA-PSS\");",
                "        AlgorithmParameters algParams2 =",
                "            AlgorithmParameters.getInstance(\"RSASSA-PSS\");",
                "        algParams1.init(new PSSParameterSpec(\"SHA-1\", \"MGF1\",",
                "            MGF1ParameterSpec.SHA1, 20, PSSParameterSpec.TRAILER_FIELD_BC));",
                "        algParams2.init(new PSSParameterSpec(\"SHA-256\", \"MGF1\",",
                "            MGF1ParameterSpec.SHA1, 20, PSSParameterSpec.TRAILER_FIELD_BC));",
                "        ai1 = new AlgorithmId(AlgorithmId.RSASSA_PSS_oid, algParams1);",
                "        ai2 = new AlgorithmId(AlgorithmId.RSASSA_PSS_oid, algParams2);",
                "        if (ai1.equals(ai2)) {",
                "            throw new Exception(\"Failed equals() contract\");",
                "        } else {",
                "            System.out.println(\"PASSED equals() test\");",
                "        }",
                "",
                "        // check that two AlgorithmIds created with the same parameters but",
                "        // one with DER encoded parameters and the other with",
                "        // AlgorithmParameters are equal",
                "        byte[] encoded = ai1.encode();",
                "        ai3 = AlgorithmId.parse(new DerValue(encoded));",
                "        if (!ai1.equals(ai3)) {",
                "            throw new Exception(\"Failed equals() contract\");",
                "        } else {",
                "            System.out.println(\"PASSED equals() test\");",
                "        }",
                "",
                "        // check that two AlgorithmIds created with different parameters but",
                "        // one with DER encoded parameters and the other with",
                "        // AlgorithmParameters are not equal",
                "        if (ai2.equals(ai3)) {",
                "            throw new Exception(\"Failed equals() contract\");",
                "        } else {",
                "            System.out.println(\"PASSED equals() test\");",
                "        }",
                "     }"
            ],
            "minus_lines": []
        }
    }
}
