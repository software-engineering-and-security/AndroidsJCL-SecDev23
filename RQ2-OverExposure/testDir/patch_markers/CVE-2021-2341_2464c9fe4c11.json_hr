{
    "impl/FtpClient.java": {
        "chunk_0": {
            "plus_lines": [
                " ",
                "import java.io.BufferedInputStream;",
                "import java.io.BufferedOutputStream;",
                "import java.io.BufferedReader;",
                "import java.io.Closeable;",
                "import java.io.FileNotFoundException;",
                "import java.io.IOException;",
                "import java.io.InputStream;",
                "import java.io.InputStreamReader;",
                "import java.io.OutputStream;",
                "import java.io.PrintStream;",
                "import java.io.UnsupportedEncodingException;",
                "import java.net.Inet6Address;",
                "import java.net.InetAddress;",
                "import java.net.InetSocketAddress;",
                "import java.net.Proxy;",
                "import java.net.ServerSocket;",
                "import java.net.Socket;",
                "import java.net.SocketAddress;",
                " import java.security.AccessController;"
            ],
            "minus_lines": [
                " ",
                "import java.net.*;",
                "import java.io.*;",
                " import java.security.AccessController;"
            ]
        },
        "chunk_1": {
            "plus_lines": [
                " import java.security.PrivilegedAction;",
                "import java.security.PrivilegedExceptionAction;",
                " import java.text.DateFormat;"
            ],
            "minus_lines": []
        },
        "chunk_2": {
            "plus_lines": [
                " import java.util.ArrayList;",
                "import java.util.Arrays;",
                " import java.util.Calendar;"
            ],
            "minus_lines": []
        },
        "chunk_3": {
            "plus_lines": [
                " import sun.misc.BASE64Encoder;",
                "import sun.net.ftp.FtpDirEntry;",
                "import sun.net.ftp.FtpDirParser;",
                "import sun.net.ftp.FtpProtocolException;",
                "import sun.net.ftp.FtpReplyCode;",
                "import sun.net.util.IPAddressUtil;",
                " import sun.util.logging.PlatformLogger;"
            ],
            "minus_lines": [
                " import sun.misc.BASE64Encoder;",
                "import sun.net.ftp.*;",
                " import sun.util.logging.PlatformLogger;"
            ]
        },
        "chunk_4": {
            "plus_lines": [
                "     private DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, java.util.Locale.US);",
                "    private static final boolean acceptPasvAddressVal;",
                "     static {"
            ],
            "minus_lines": [
                "     private DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, java.util.Locale.US);",
                "",
                "     static {"
            ]
        },
        "chunk_5": {
            "plus_lines": [
                "         final String encs[] = {null};",
                "        final String acceptPasvAddress[] = {null};",
                "         AccessController.doPrivileged("
            ],
            "minus_lines": [
                "         final String encs[] = {null};",
                "",
                "         AccessController.doPrivileged("
            ]
        },
        "chunk_6": {
            "plus_lines": [
                "                     public Object run() {",
                "                        acceptPasvAddress[0] = System.getProperty(\"jdk.net.ftp.trustPasvAddress\", \"false\");",
                "                         vals[0] = Integer.getInteger(\"sun.net.client.defaultReadTimeout\", 300_000).intValue();"
            ],
            "minus_lines": []
        },
        "chunk_7": {
            "plus_lines": [
                "         }",
                "",
                "        acceptPasvAddressVal = Boolean.parseBoolean(acceptPasvAddress[0]);",
                "     }"
            ],
            "minus_lines": []
        },
        "chunk_8": {
            "plus_lines": [],
            "minus_lines": [
                "             // the parenthesis are optionals and we have to use 3 groups.",
                "",
                "             if (pasvPat == null) {"
            ]
        },
        "chunk_9": {
            "plus_lines": [
                "             String s = m.group(1).replace(',', '.');",
                "            if (!IPAddressUtil.isIPv4LiteralAddress(s))",
                "                throw new FtpProtocolException(\"PASV failed : \"  + serverAnswer);",
                "            if (acceptPasvAddressVal) {",
                "                dest = new InetSocketAddress(s, port);",
                "            } else {",
                "                dest = validatePasvAddress(port, s, server.getInetAddress());",
                "            }",
                "         }"
            ],
            "minus_lines": [
                "             String s = m.group(1).replace(',', '.');",
                "            dest = new InetSocketAddress(s, port);",
                "         }"
            ]
        },
        "chunk_10": {
            "plus_lines": [
                "         }",
                "",
                "         // Got everything, let's open the socket!"
            ],
            "minus_lines": []
        },
        "chunk_11": {
            "plus_lines": [
                " ",
                "    static final String ERROR_MSG = \"Address should be the same as originating server\";",
                "",
                "    /**",
                "     * Returns an InetSocketAddress, based on value of acceptPasvAddressVal",
                "     * and other conditions such as the server address returned by pasv",
                "     * is not a hostname, is a socks proxy, or the loopback. An exception",
                "     * is thrown if none of the valid conditions are met.",
                "     */",
                "    private InetSocketAddress validatePasvAddress(int port, String s, InetAddress address)",
                "        throws FtpProtocolException",
                "    {",
                "        if (address == null) {",
                "            return InetSocketAddress.createUnresolved(serverAddr.getHostName(), port);",
                "        }",
                "        String serverAddress = address.getHostAddress();",
                "        if (serverAddress.equals(s)) {",
                "            return new InetSocketAddress(s, port);",
                "        } else if (address.isLoopbackAddress() && s.startsWith(\"127.\")) { // can be 127.0",
                "            return new InetSocketAddress(s, port);",
                "        } else if (address.isLoopbackAddress()) {",
                "            if (privilegedLocalHost().getHostAddress().equals(s)) {",
                "                return new InetSocketAddress(s, port);",
                "            } else {",
                "                throw new FtpProtocolException(ERROR_MSG);",
                "            }",
                "        } else if (s.startsWith(\"127.\")) {",
                "            if (privilegedLocalHost().equals(address)) {",
                "                return new InetSocketAddress(s, port);",
                "            } else {",
                "                throw new FtpProtocolException(ERROR_MSG);",
                "            }",
                "        }",
                "        String hostName = address.getHostName();",
                "        if (!(IPAddressUtil.isIPv4LiteralAddress(hostName) || IPAddressUtil.isIPv6LiteralAddress(hostName))) {",
                "            InetAddress[] names = privilegedGetAllByName(hostName);",
                "            String resAddress = Arrays",
                "                .stream(names)",
                "                .map(InetAddress::getHostAddress)",
                "                .filter(s::equalsIgnoreCase)",
                "                .findFirst()",
                "                .orElse(null);",
                "            if (resAddress != null) {",
                "                return new InetSocketAddress(s, port);",
                "            }",
                "        }",
                "        throw new FtpProtocolException(ERROR_MSG);",
                "    }",
                "",
                "    private static InetAddress privilegedLocalHost() throws FtpProtocolException {",
                "        PrivilegedExceptionAction<InetAddress> action = InetAddress::getLocalHost;",
                "        try {",
                "            return AccessController.doPrivileged(action);",
                "        } catch (Exception e) {",
                "            FtpProtocolException ftpEx = new FtpProtocolException(ERROR_MSG);",
                "            ftpEx.initCause(e);",
                "            throw ftpEx;",
                "        }",
                "    }",
                "",
                "    private static InetAddress[] privilegedGetAllByName(String hostName) throws FtpProtocolException {",
                "        PrivilegedExceptionAction<InetAddress[]> pAction = () -> InetAddress.getAllByName(hostName);",
                "        try {",
                "            return AccessController.doPrivileged(pAction);",
                "        } catch (Exception e) {",
                "            FtpProtocolException ftpEx = new FtpProtocolException(ERROR_MSG);",
                "            ftpEx.initCause(e);",
                "            throw ftpEx;",
                "        }",
                "    }",
                "",
                "     /**"
            ],
            "minus_lines": []
        },
        "chunk_12": {
            "plus_lines": [],
            "minus_lines": [
                "         Socket clientSocket;",
                "",
                "         if (passiveMode) {"
            ]
        }
    }
}
